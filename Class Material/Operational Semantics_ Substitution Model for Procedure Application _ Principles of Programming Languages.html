<!DOCTYPE html>
<!-- saved from url=(0078)https://bguppl.github.io/interpreters/class_material/2.6SubstitutionModel.html -->
<html lang=" en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="module" id="truffle-injected" data-runtime="bkkjeefjfjcfdfifddmkdmcpmaakmelp" src="chrome-extension://bkkjeefjfjcfdfifddmkdmcpmaakmelp/injected-script/index.js"></script>

    
    

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Operational Semantics: Substitution Model for Procedure Application | Principles of Programming Languages</title>
<meta name="generator" content="Jekyll v3.10.0">
<meta property="og:title" content="Operational Semantics: Substitution Model for Procedure Application">
<meta property="og:locale" content="en_US">
<meta name="description" content="Course Website">
<meta property="og:description" content="Course Website">
<link rel="canonical" href="https://bguppl.github.io/interpreters/class_material/2.6SubstitutionModel.html">
<meta property="og:url" content="https://bguppl.github.io/interpreters/class_material/2.6SubstitutionModel.html">
<meta property="og:site_name" content="Principles of Programming Languages">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Operational Semantics: Substitution Model for Procedure Application">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Course Website","headline":"Operational Semantics: Substitution Model for Procedure Application","url":"https://bguppl.github.io/interpreters/class_material/2.6SubstitutionModel.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com/">
    <link rel="preload" href="./Operational Semantics_ Substitution Model for Procedure Application _ Principles of Programming Languages_files/css" as="style" type="text/css" crossorigin="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="./Operational Semantics_ Substitution Model for Procedure Application _ Principles of Programming Languages_files/style.css">
<style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style><style id="MJX-CHTML-styles">
mjx-container[jax="CHTML"] {
  line-height: 0;
}

mjx-container [space="1"] {
  margin-left: .111em;
}

mjx-container [space="2"] {
  margin-left: .167em;
}

mjx-container [space="3"] {
  margin-left: .222em;
}

mjx-container [space="4"] {
  margin-left: .278em;
}

mjx-container [space="5"] {
  margin-left: .333em;
}

mjx-container [rspace="1"] {
  margin-right: .111em;
}

mjx-container [rspace="2"] {
  margin-right: .167em;
}

mjx-container [rspace="3"] {
  margin-right: .222em;
}

mjx-container [rspace="4"] {
  margin-right: .278em;
}

mjx-container [rspace="5"] {
  margin-right: .333em;
}

mjx-container [size="s"] {
  font-size: 70.7%;
}

mjx-container [size="ss"] {
  font-size: 50%;
}

mjx-container [size="Tn"] {
  font-size: 60%;
}

mjx-container [size="sm"] {
  font-size: 85%;
}

mjx-container [size="lg"] {
  font-size: 120%;
}

mjx-container [size="Lg"] {
  font-size: 144%;
}

mjx-container [size="LG"] {
  font-size: 173%;
}

mjx-container [size="hg"] {
  font-size: 207%;
}

mjx-container [size="HG"] {
  font-size: 249%;
}

mjx-container [width="full"] {
  width: 100%;
}

mjx-box {
  display: inline-block;
}

mjx-block {
  display: block;
}

mjx-itable {
  display: inline-table;
}

mjx-row {
  display: table-row;
}

mjx-row > * {
  display: table-cell;
}

mjx-mtext {
  display: inline-block;
}

mjx-mstyle {
  display: inline-block;
}

mjx-merror {
  display: inline-block;
  color: red;
  background-color: yellow;
}

mjx-mphantom {
  visibility: hidden;
}

_::-webkit-full-page-media, _:future, :root mjx-container {
  will-change: opacity;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-math {
  display: inline-block;
  text-align: left;
  line-height: 0;
  text-indent: 0;
  font-style: normal;
  font-weight: normal;
  font-size: 100%;
  font-size-adjust: none;
  letter-spacing: normal;
  border-collapse: collapse;
  word-wrap: normal;
  word-spacing: normal;
  white-space: nowrap;
  direction: ltr;
  padding: 1px 0;
}

mjx-container[jax="CHTML"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="CHTML"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="CHTML"][display="true"] mjx-math {
  padding: 0;
}

mjx-container[jax="CHTML"][justify="left"] {
  text-align: left;
}

mjx-container[jax="CHTML"][justify="right"] {
  text-align: right;
}

mjx-mi {
  display: inline-block;
  text-align: left;
}

mjx-c {
  display: inline-block;
}

mjx-utext {
  display: inline-block;
  padding: .75em 0 .2em 0;
}

mjx-mn {
  display: inline-block;
  text-align: left;
}

mjx-msup {
  display: inline-block;
  text-align: left;
}

mjx-mo {
  display: inline-block;
  text-align: left;
}

mjx-stretchy-h {
  display: inline-table;
  width: 100%;
}

mjx-stretchy-h > * {
  display: table-cell;
  width: 0;
}

mjx-stretchy-h > * > mjx-c {
  display: inline-block;
  transform: scalex(1.0000001);
}

mjx-stretchy-h > * > mjx-c::before {
  display: inline-block;
  width: initial;
}

mjx-stretchy-h > mjx-ext {
  /* IE */ overflow: hidden;
  /* others */ overflow: clip visible;
  width: 100%;
}

mjx-stretchy-h > mjx-ext > mjx-c::before {
  transform: scalex(500);
}

mjx-stretchy-h > mjx-ext > mjx-c {
  width: 0;
}

mjx-stretchy-h > mjx-beg > mjx-c {
  margin-right: -.1em;
}

mjx-stretchy-h > mjx-end > mjx-c {
  margin-left: -.1em;
}

mjx-stretchy-v {
  display: inline-block;
}

mjx-stretchy-v > * {
  display: block;
}

mjx-stretchy-v > mjx-beg {
  height: 0;
}

mjx-stretchy-v > mjx-end > mjx-c {
  display: block;
}

mjx-stretchy-v > * > mjx-c {
  transform: scaley(1.0000001);
  transform-origin: left center;
  overflow: hidden;
}

mjx-stretchy-v > mjx-ext {
  display: block;
  height: 100%;
  box-sizing: border-box;
  border: 0px solid transparent;
  /* IE */ overflow: hidden;
  /* others */ overflow: visible clip;
}

mjx-stretchy-v > mjx-ext > mjx-c::before {
  width: initial;
  box-sizing: border-box;
}

mjx-stretchy-v > mjx-ext > mjx-c {
  transform: scaleY(500) translateY(.075em);
  overflow: visible;
}

mjx-mark {
  display: inline-block;
  height: 0px;
}

mjx-c::before {
  display: block;
  width: 0;
}

.MJX-TEX {
  font-family: MJXZERO, MJXTEX;
}

.TEX-B {
  font-family: MJXZERO, MJXTEX-B;
}

.TEX-I {
  font-family: MJXZERO, MJXTEX-I;
}

.TEX-MI {
  font-family: MJXZERO, MJXTEX-MI;
}

.TEX-BI {
  font-family: MJXZERO, MJXTEX-BI;
}

.TEX-S1 {
  font-family: MJXZERO, MJXTEX-S1;
}

.TEX-S2 {
  font-family: MJXZERO, MJXTEX-S2;
}

.TEX-S3 {
  font-family: MJXZERO, MJXTEX-S3;
}

.TEX-S4 {
  font-family: MJXZERO, MJXTEX-S4;
}

.TEX-A {
  font-family: MJXZERO, MJXTEX-A;
}

.TEX-C {
  font-family: MJXZERO, MJXTEX-C;
}

.TEX-CB {
  font-family: MJXZERO, MJXTEX-CB;
}

.TEX-FR {
  font-family: MJXZERO, MJXTEX-FR;
}

.TEX-FRB {
  font-family: MJXZERO, MJXTEX-FRB;
}

.TEX-SS {
  font-family: MJXZERO, MJXTEX-SS;
}

.TEX-SSB {
  font-family: MJXZERO, MJXTEX-SSB;
}

.TEX-SSI {
  font-family: MJXZERO, MJXTEX-SSI;
}

.TEX-SC {
  font-family: MJXZERO, MJXTEX-SC;
}

.TEX-T {
  font-family: MJXZERO, MJXTEX-T;
}

.TEX-V {
  font-family: MJXZERO, MJXTEX-V;
}

.TEX-VB {
  font-family: MJXZERO, MJXTEX-VB;
}

mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c {
  font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A ! important;
}

@font-face /* 0 */ {
  font-family: MJXZERO;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff");
}

@font-face /* 1 */ {
  font-family: MJXTEX;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff");
}

@font-face /* 2 */ {
  font-family: MJXTEX-B;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff");
}

@font-face /* 3 */ {
  font-family: MJXTEX-I;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff");
}

@font-face /* 4 */ {
  font-family: MJXTEX-MI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff");
}

@font-face /* 5 */ {
  font-family: MJXTEX-BI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff");
}

@font-face /* 6 */ {
  font-family: MJXTEX-S1;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff");
}

@font-face /* 7 */ {
  font-family: MJXTEX-S2;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff");
}

@font-face /* 8 */ {
  font-family: MJXTEX-S3;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff");
}

@font-face /* 9 */ {
  font-family: MJXTEX-S4;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff");
}

@font-face /* 10 */ {
  font-family: MJXTEX-A;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff");
}

@font-face /* 11 */ {
  font-family: MJXTEX-C;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff");
}

@font-face /* 12 */ {
  font-family: MJXTEX-CB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff");
}

@font-face /* 13 */ {
  font-family: MJXTEX-FR;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff");
}

@font-face /* 14 */ {
  font-family: MJXTEX-FRB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff");
}

@font-face /* 15 */ {
  font-family: MJXTEX-SS;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff");
}

@font-face /* 16 */ {
  font-family: MJXTEX-SSB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff");
}

@font-face /* 17 */ {
  font-family: MJXTEX-SSI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff");
}

@font-face /* 18 */ {
  font-family: MJXTEX-SC;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff");
}

@font-face /* 19 */ {
  font-family: MJXTEX-T;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff");
}

@font-face /* 20 */ {
  font-family: MJXTEX-V;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff");
}

@font-face /* 21 */ {
  font-family: MJXTEX-VB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff");
}

mjx-c.mjx-c1D43F.TEX-I::before {
  padding: 0.683em 0.681em 0 0;
  content: "L";
}

mjx-c.mjx-c32::before {
  padding: 0.666em 0.5em 0 0;
  content: "2";
}

mjx-c.mjx-c31::before {
  padding: 0.666em 0.5em 0 0;
  content: "1";
}

mjx-c.mjx-c1D460.TEX-I::before {
  padding: 0.442em 0.469em 0.01em 0;
  content: "s";
}

mjx-c.mjx-c2032::before {
  padding: 0.56em 0.275em 0 0;
  content: "\2032";
}

mjx-c.mjx-c2218::before {
  padding: 0.444em 0.5em 0 0;
  content: "\2218";
}

mjx-c.mjx-c2033::before {
  padding: 0.56em 0.55em 0 0;
  content: "\2032\2032";
}

mjx-c.mjx-c1D465.TEX-I::before {
  padding: 0.442em 0.572em 0.011em 0;
  content: "x";
}

mjx-c.mjx-c28::before {
  padding: 0.75em 0.389em 0.25em 0;
  content: "(";
}

mjx-c.mjx-c29::before {
  padding: 0.75em 0.389em 0.25em 0;
  content: ")";
}

mjx-c.mjx-c7B::before {
  padding: 0.75em 0.5em 0.25em 0;
  content: "{";
}

mjx-c.mjx-c7D::before {
  padding: 0.75em 0.5em 0.25em 0;
  content: "}";
}

mjx-c.mjx-c3D::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "=";
}

mjx-c.mjx-c1D438.TEX-I::before {
  padding: 0.68em 0.764em 0 0;
  content: "E";
}

mjx-c.mjx-c33::before {
  padding: 0.665em 0.5em 0.022em 0;
  content: "3";
}

mjx-c.mjx-c5B::before {
  padding: 0.75em 0.278em 0.25em 0;
  content: "[";
}

mjx-c.mjx-c5D::before {
  padding: 0.75em 0.278em 0.25em 0;
  content: "]";
}

mjx-c.mjx-c1D706.TEX-I::before {
  padding: 0.694em 0.583em 0.012em 0;
  content: "\3BB";
}

mjx-c.mjx-c2212::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "\2212";
}

mjx-c.mjx-c1D450.TEX-I::before {
  padding: 0.442em 0.433em 0.011em 0;
  content: "c";
}

mjx-c.mjx-c1D44E.TEX-I::before {
  padding: 0.441em 0.529em 0.01em 0;
  content: "a";
}

mjx-c.mjx-c1D459.TEX-I::before {
  padding: 0.694em 0.298em 0.011em 0;
  content: "l";
}

mjx-c.mjx-c1D462.TEX-I::before {
  padding: 0.442em 0.572em 0.011em 0;
  content: "u";
}
</style></head>

<body>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async="" src="./Operational Semantics_ Substitution Model for Procedure Application _ Principles of Programming Languages_files/tex-mml-chtml.js.download"></script>

    <header class="page-header" role="banner">
        <h1 class="project-name">Principles of Programming Languages</h1>
        <h2 class="project-tagline">Course Website</h2>
        
        <a href="https://github.com/bguppl/interpreters" class="btn">View on GitHub</a>
        
        
    </header>

    <main id="content" class="main-content" role="main">
        <h1 id="operational-semantics-substitution-model-for-procedure-application">Operational Semantics: Substitution Model for Procedure Application</h1>

<h2 id="ppl-2023">PPL 2023</h2>

<p>We continue our exploration of operational semantics by addressing the case of procedure application.
The <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="0" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> language extends <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="1" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>1</mn></math></mjx-assistive-mml></mjx-container> by introducing:</p>
<ul>
  <li>User defined procedures (lambda expressions)</li>
  <li>Conditional expressions (if expressions)</li>
</ul>

<p>These two constructs combine well - so that we can construct recursive functions (which require a condition between the base case and the recursive case).</p>

<h2 id="l2-syntax"><mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="2" style="font-size: 117.3%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> Syntax</h2>

<p>The syntax of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="3" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> extends that of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="4" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>1</mn></math></mjx-assistive-mml></mjx-container> with two new expression types - <code class="language-plaintext highlighter-rouge">if-exp</code> and <code class="language-plaintext highlighter-rouge">proc-exp</code>:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">program</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span><span class="nx">L2</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;+</span><span class="p">)</span> <span class="c1">// program(exps:List(exp))</span>
<span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="nx">define</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">define</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span><span class="nx">define</span> <span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">decl</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;</span><span class="p">)</span> <span class="c1">// def-exp(var:var-decl, val:cexp)</span>
<span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="nx">num</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="c1">// num-exp(val:Number)</span>
       <span class="o">|</span> <span class="o">&lt;</span><span class="nx">bool</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span>  <span class="c1">// bool-exp(val:Boolean)</span>
       <span class="o">|</span> <span class="o">&lt;</span><span class="nx">prim</span><span class="o">-</span><span class="nx">op</span><span class="o">&gt;</span>   <span class="c1">// prim-op(op:string)</span>
       <span class="o">|</span> <span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">ref</span><span class="o">&gt;</span>   <span class="c1">// var-ref(var:string)</span>
       <span class="o">|</span> <span class="p">(</span><span class="k">if</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;</span><span class="p">)</span> <span class="c1">// if-exp(test,then,else)                                   ##### L2</span>
       <span class="o">|</span> <span class="p">(</span><span class="nx">lambda</span> <span class="p">(</span><span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">decl</span><span class="o">&gt;*</span><span class="p">)</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;+</span><span class="p">)</span> <span class="c1">// proc-exp(params:List(var-decl), body:List(cexp)) ##### L2</span>
       <span class="o">|</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;*</span><span class="p">)</span> <span class="c1">// app-exp(rator:cexp, rands:List(cexp))</span>
<span class="o">&lt;</span><span class="nx">prim</span><span class="o">-</span><span class="nx">op</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">+</span> <span class="o">|</span> <span class="o">-</span> <span class="o">|</span> <span class="o">*</span> <span class="o">|</span> <span class="sr">/ | &lt; | &gt; | = | no</span><span class="err">t
</span><span class="o">&lt;</span><span class="nx">num</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nx">a</span> <span class="kr">number</span> <span class="nx">token</span>
<span class="o">&lt;</span><span class="nx">bool</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="err">#</span><span class="nx">t</span> <span class="o">|</span> <span class="err">#</span><span class="nx">f</span>
<span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">ref</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nx">an</span> <span class="nx">identifier</span> <span class="nx">token</span>
<span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">decl</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nx">an</span> <span class="nx">identifier</span> <span class="nx">token</span>
</code></pre></div></div>

<p>The corresponding TypeScript implementation of this AST (and its extension into L3) with a <code class="language-plaintext highlighter-rouge">parseL3</code> function is provided
in <a href="https://github.com/bguppl/interpreters/blob/master/src/L3/L3-ast.ts">L3-ast.ts</a></p>

<h2 id="l2-value-type"><mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="5" style="font-size: 117.3%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> Value Type</h2>

<p>A program in <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="6" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> can now use user defined procedures such as:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">L2</span> 
  <span class="p">(</span><span class="k">define</span> <span class="nv">square</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">3</span><span class="p">)))</span>
</code></pre></div></div>

<p>To determine which values can be computed by <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="7" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> programs, we proceed inductively on the structure of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="8" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container>-ASTs.
The same values as those in <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="9" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>1</mn></math></mjx-assistive-mml></mjx-container> can be computed, and we must analyze the two new types of expressions:</p>
<ul>
  <li>IfExp expressions return the value of either the then-branch or the else-branch, which can be any cexp expressions.
Thus if-exp does not compute new types of values.</li>
  <li>ProcExp expressions return a new type of value - which we have called a <strong>closure</strong>.</li>
</ul>

<p>We must then extend the definition of the Value type to include closure values:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Value</span> <span class="o">=</span> <span class="nb">Number</span> <span class="o">|</span> <span class="nb">Boolean</span> <span class="o">|</span> <span class="nx">Prim</span><span class="o">-</span><span class="nx">op</span> <span class="o">|</span> <span class="nx">Void</span> <span class="o">|</span> <span class="nx">Closure</span>
</code></pre></div></div>

<p>We define the closure data type as a record with two fields:</p>
<ul>
  <li>Params: a list of var-decl values</li>
  <li>Body: a list of cexp values</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Closure</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span><span class="nx">Closure</span> <span class="p">(</span><span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">decl</span><span class="o">&gt;*</span><span class="p">)</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;+</span><span class="p">)</span> <span class="c1">// closure(params:List(var-decl), body:List(cexp))</span>
</code></pre></div></div>

<p>Note that a ProcExp <code class="language-plaintext highlighter-rouge">(lambda (x) (* x x))</code> is an <strong>expression</strong> while a closure is a <strong>value</strong>.
They are of 2 different types - closures are the result of a computation.</p>

<h2 id="l2-evaluation-rules"><mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="10" style="font-size: 117.3%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> Evaluation Rules</h2>

<p>The evaluation rules that define the operational semantics of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="11" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> include the same rules as those of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="12" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>1</mn></math></mjx-assistive-mml></mjx-container> for the <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="13" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>1</mn></math></mjx-assistive-mml></mjx-container> expression types.  We must specify evaluation rules for the new expression types:</p>

<h3 id="evaluation-of-conditional-expressions">Evaluation of Conditional Expressions</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span><span class="p">(</span><span class="nx">IfExp</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span> <span class="nx">then</span><span class="p">,</span> <span class="k">else</span><span class="p">),</span> <span class="nx">env</span><span class="p">)</span> <span class="o">=&gt;</span> 
    <span class="c1">// test, then, else are of type cexp</span>
    <span class="kd">let</span> <span class="nx">c</span><span class="p">:</span><span class="nx">Value</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span> <span class="nx">env</span><span class="p">)</span>
        <span class="nx">If</span> <span class="nx">c</span> <span class="k">is</span> <span class="nx">considered</span> <span class="nx">a</span> <span class="kc">true</span> <span class="nx">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">then</span><span class="p">,</span> <span class="nx">env</span><span class="p">)</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="k">else</span><span class="p">,</span> <span class="nx">env</span><span class="p">)</span>
</code></pre></div></div>

<p>We must define what counts as a true value in the testing of the condition in an <code class="language-plaintext highlighter-rouge">IfExp</code>.
This definition of what counts as true is a semantic decision - which is different in different languages.</p>

<p>In Scheme, a true value is anything that is not <code class="language-plaintext highlighter-rouge">#f</code>.  We implement this in this procedure in our interpreter code:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Purpose: Define what is considered a true value in an if-exp</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">isTrueValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">Value</span><span class="p">):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span>
    <span class="o">!</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>In JavaScript, the definition of what counts as true in an IfExp is more complicated - it is any value that is:</p>
<ul>
  <li>not false</li>
  <li>not undefined</li>
  <li>not null</li>
  <li>not +0, not -0, not NaN (not a number, the result of performing an arithmetic operation which cannot return a valid number)</li>
  <li>not an empty string</li>
</ul>

<h3 id="evaluation-of-procedure-expressions">Evaluation of Procedure Expressions</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span><span class="p">(</span><span class="nx">proc</span><span class="o">-</span><span class="nx">exp</span><span class="p">(</span><span class="nx">params</span><span class="p">,</span> <span class="nx">body</span><span class="p">),</span> <span class="nx">env</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="c1">// Construct a closure value</span>
    <span class="k">return</span> <span class="nx">makeClosure</span><span class="p">(</span><span class="nx">params</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span>
</code></pre></div></div>

<p>When we compute the value of a procedure expression, there is no actual computation going on besides the packaging of the parameters and the body into a closure record.<br>
The body is not computed as this stage.
It will only be computed when the procedure is actually applied to arguments.</p>

<p>This property is important: it means we can <strong>delay</strong> the computation of an expression by wrapping it inside a procedure,
and invoking the procedure only later.  We will exploit this property in Chapter 4.</p>

<h2 id="procedure-application">Procedure Application</h2>

<p>We have covered the two new types of expressions with the evaluation rules above – but another place in the operational semantics must now be updated because of the presence of closures: procedure application.</p>

<p>In the <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="14" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>1</mn></math></mjx-assistive-mml></mjx-container> case, the only procedure value that could be applied to arguments was a primitive operator.
This was covered in the evaluation rule for <code class="language-plaintext highlighter-rouge">AppExp</code> expressions:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span><span class="p">(</span><span class="nx">AppExp</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span> <span class="nx">rands</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="c1">// rator is of type Cexp</span>
    <span class="c1">// rands is of type List(Cexp)</span>
    <span class="kd">let</span> <span class="nx">proc</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span><span class="nx">env</span><span class="p">)</span>
        <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">eval</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span><span class="nx">env</span><span class="p">)</span> <span class="k">for</span> <span class="nx">r</span> <span class="k">in</span> <span class="nx">rands</span><span class="p">]</span>
        <span class="k">return</span> <span class="nx">applyProc</span><span class="p">(</span><span class="nx">proc</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ApplyProc</code> defines how a procedure value is applied to values.
We must now define how a closure value is applied to argument values.</p>

<p>In order to evaluate an <code class="language-plaintext highlighter-rouge">AppExp</code> whose operator evaluates to a closure, we followed the same process as for primitive procedures: first evaluate the elements of the combination, then apply the closure (which is the value of the operator) to the arguments (which are the values of the operands).  This strategy is what is called <strong>applicative order evaluation</strong>.  It is the standard evaluation strategy in most programming languages, but we will discuss an alternative strategy in the next section (<em>normal evaluation</em>).</p>

<p>To apply a closure to arguments, we define the <strong>substitution model</strong>: evaluate the body of the closure with each formal parameter replaced by the corresponding argument.</p>

<p>Let’s follow an example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">square</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">square</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>The evaluation process is the following:</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">.</span> <span class="nv">Evaluate</span> <span class="nv">defineExp:</span>
    <span class="mf">1.1</span> <span class="nv">Evaluate</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
    <span class="mf">1.2</span> <span class="nv">Bind</span> <span class="nv">square</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">value</span> <span class="p">(</span><span class="nf">closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">global</span> <span class="nv">environment</span>
<span class="mi">2</span><span class="o">.</span> <span class="nv">Evaluate</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nf">an</span> <span class="nv">AppExp</span><span class="p">)</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">global</span> <span class="nv">environment:</span>
    <span class="mf">2.1</span> <span class="nv">Evaluate</span> <span class="nv">square</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">VarRef</span> <span class="nv">expression</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
    <span class="mf">2.2</span> <span class="nv">Evaluate</span> <span class="mi">5</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">NumExp</span> <span class="nv">expression</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">5</span>
    <span class="mf">2.3</span> <span class="nv">ApplyProc</span><span class="p">[</span> <span class="p">(</span><span class="nf">closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">5</span><span class="p">)</span> <span class="p">]</span>
        <span class="c1">;; To clarify the process let us use full AST for the closure elements</span>
        <span class="c1">;; (closure [(VarDecl x)] [(AppExp (PrimOp *) [(VarRef x), (VarRef x)])])</span>
        <span class="mf">2.3</span><span class="o">.</span><span class="mi">1</span> <span class="nv">Substitute</span> <span class="nv">the</span> <span class="nv">VarRef</span> <span class="nv">free</span> <span class="nv">occurrences</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">VarDecl</span> <span class="nv">in</span> <span class="nv">body</span> 
              <span class="nv">with</span> <span class="nv">the</span> <span class="nv">corresponding</span> <span class="nv">value</span>
              <span class="nv">Substituted-body</span> <span class="nv">=</span> <span class="p">[(</span><span class="nf">AppExp</span> <span class="p">(</span><span class="nf">PrimOp</span> <span class="nv">*</span><span class="p">)</span> <span class="p">[</span><span class="nf">5,</span> <span class="mi">5</span><span class="p">])]</span>
        <span class="mf">2.3</span><span class="o">.</span><span class="mi">2</span> <span class="nv">Evaluate</span> <span class="nv">the</span> <span class="nv">resulting</span> <span class="nv">substituted</span> <span class="nv">body:</span>
            <span class="nv">return</span> <span class="nv">eval</span><span class="p">(</span><span class="nf">substituted-body</span><span class="p">)</span>
                <span class="mf">2.3</span><span class="o">.</span><span class="mf">2.1</span> <span class="nv">Eval</span> <span class="p">(</span><span class="nf">PrimOp</span> <span class="nv">*</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">PrimOp</span> <span class="nv">*</span><span class="p">)</span>
                <span class="mf">2.3</span><span class="o">.</span><span class="mf">2.2</span> <span class="nv">Eval</span> <span class="mi">5</span> <span class="nv">=&gt;</span> <span class="mi">5</span>
                <span class="mf">2.3</span><span class="o">.</span><span class="mf">2.3</span> <span class="nv">Eval</span> <span class="mi">5</span> <span class="nv">=&gt;</span> <span class="mi">5</span>
                <span class="mf">2.3</span><span class="o">.</span><span class="mf">2.4</span> <span class="nv">ApplyProc</span><span class="p">(</span> <span class="p">(</span><span class="nf">PrimOp</span> <span class="nv">*</span><span class="p">)</span><span class="o">,</span> <span class="p">[</span><span class="nf">5,</span> <span class="mi">5</span><span class="p">]</span> <span class="p">)</span>
                    <span class="mf">2.3</span><span class="o">.</span><span class="mf">2.4</span><span class="o">.</span><span class="mi">1</span> <span class="nv">ApplyPrimitive</span><span class="p">(</span> <span class="p">(</span><span class="nf">PrimOp</span> <span class="nv">*</span><span class="p">)</span><span class="o">,</span> <span class="p">[</span><span class="nf">5,</span> <span class="mi">5</span><span class="p">]</span> <span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">25</span>
</code></pre></div></div>

<p>We must clarify three aspects of the applicative-eval substitution model:</p>
<ul>
  <li>Type of the substituted elements into the AST of the body</li>
  <li>Substitute only free occurrences of the params in the body</li>
  <li>Need to rename bound variables inside the body to avoid variable capture</li>
</ul>

<h3 id="substitute-expressions-instead-of-values">Substitute Expressions instead of Values</h3>

<p>Let us analyze the types of the objects manipulated in the substitution operation above:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">;; (closure [(VarDecl x)] [(AppExp (PrimOp *) [(VarRef x), (VarRef x)])])</span>
    <span class="mf">2.3</span><span class="o">.</span><span class="mi">1</span> <span class="nv">Substitute</span> <span class="nv">the</span> <span class="nv">VarRef</span> <span class="nv">free</span> <span class="nv">occurrences</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">VarDecl</span> <span class="nv">in</span> <span class="nv">body</span> 
            <span class="nv">with</span> <span class="nv">the</span> <span class="nv">corresponding</span> <span class="nv">value</span>
            <span class="nv">Substituted-body</span> <span class="nv">=</span> <span class="p">[(</span><span class="nf">AppExp</span> <span class="p">(</span><span class="nf">PrimOp</span> <span class="nv">*</span><span class="p">)</span> <span class="p">[</span><span class="nf">5,</span> <span class="mi">5</span><span class="p">])]</span>
</code></pre></div></div>

<p>The applyProc procedure receives arguments which are all of type <code class="language-plaintext highlighter-rouge">Value</code> (proc is a <code class="language-plaintext highlighter-rouge">Value</code> which can be either a PrimOp or a Closure value, rands is a list of Values).</p>

<p>The body of the closure is a list of <code class="language-plaintext highlighter-rouge">CExp</code> expressions.
Our objective is to replace all VarRef occurrences in the body with the corresponding values of the arguments
(in our example, we want to replace <code class="language-plaintext highlighter-rouge">(VarRef x)</code> with <code class="language-plaintext highlighter-rouge">5</code>).</p>

<p>There is a typing problem with this operation: 5 is a Value, while <code class="language-plaintext highlighter-rouge">(VarRef x)</code> is an expression.
If we replace <code class="language-plaintext highlighter-rouge">(VarRef x)</code> with the value <code class="language-plaintext highlighter-rouge">5</code> (a number), the resulting body is not a valid AST.</p>

<p>To address this discrepancy, we must map the values of the arguments to corresponding expressions.
This mapping is performed in our interpreter with the following function:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Purpose: Transform a value into a literal expression denoting this value</span>
<span class="c1">// Pre-conditions: val is not void</span>
<span class="kd">const</span> <span class="nx">valueToLitExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">v</span><span class="p">:</span> <span class="nx">Value</span><span class="p">):</span> <span class="nx">NumExp</span> <span class="o">|</span> <span class="nx">BoolExp</span> <span class="o">|</span> <span class="nx">StrExp</span> <span class="o">|</span> <span class="nx">LitExp</span> <span class="o">|</span> <span class="nx">PrimOp</span> <span class="o">|</span> <span class="nx">ProcExp</span> <span class="o">=&gt;</span>
    <span class="nx">isNumber</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeNumExp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isBoolean</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeBoolExp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isString</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeStrExp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isPrimOp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">v</span> <span class="p">:</span>
    <span class="nx">isClosure</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeProcExp</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">params</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">body</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">makeLitExp</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</code></pre></div></div>

<p>As a result, the closure application above is processed as follows:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">;; (closure [(VarDecl x)] [(AppExp (PrimOp *) [(VarRef x), (VarRef x)])])</span>
    <span class="mf">2.3</span><span class="o">.</span><span class="mi">1</span> <span class="nv">Substitute</span> <span class="nv">the</span> <span class="nv">VarRef</span> <span class="nv">free</span> <span class="nv">occurrences</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">VarDecl</span> <span class="nv">in</span> <span class="nv">body</span> 
            <span class="nv">with</span> <span class="nv">the</span> <span class="nv">corresponding</span> <span class="nv">value</span>
            <span class="nv">Substituted-body</span> <span class="nv">=</span> <span class="p">[(</span><span class="nf">AppExp</span> <span class="p">(</span><span class="nf">PrimOp</span> <span class="nv">*</span><span class="p">)</span> <span class="p">[</span><span class="nf">NumExp</span><span class="p">(</span><span class="nf">5</span><span class="p">)</span><span class="o">,</span> <span class="nv">NumExp</span><span class="p">(</span><span class="nf">5</span><span class="p">)])]</span>
</code></pre></div></div>

<p>and we confirm that the resulting substituted-body is a valid AST.</p>

<p>In summary, the substitution procedure has type:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @Pre: vars and exps have the same length</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">substitute</span> <span class="o">=</span> <span class="p">(</span><span class="nx">body</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">[],</span> <span class="nx">vars</span><span class="p">:</span> <span class="kr">string</span><span class="p">[],</span> <span class="nx">exps</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">[]):</span> <span class="nx">CExp</span><span class="p">[]</span>
</code></pre></div></div>

<h3 id="substitute-only-free-variable-occurrences-in-the-body">Substitute Only Free Variable Occurrences in the Body</h3>

<p>When we apply a closure to arguments, we consider the body and the params of the closure separately.
If you look at:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</code></pre></div></div>

<p>in the body of the closure - the variable x occurs bound (it is bound by the parameter of the closure)
and the variable y occurs free.</p>

<p>If we now look at the body <em>separately</em> - <code class="language-plaintext highlighter-rouge">(* x y)</code> - then the variables which were bound to the params now appear free in the body.</p>

<p>These variable references are the occurrences we must replace with the value of the argument.</p>

<p>Consider the case of another bound occurrence of the <code class="language-plaintext highlighter-rouge">x</code> variable in the body as in this example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>            <span class="c1">; 1</span>
  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">; 2</span>
   <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>            <span class="c1">; 3</span>
</code></pre></div></div>

<p>In this case, the var-ref occurrences in line 2 are bound in the body to the var-decl in line 2,
while the occurrences in line 3 are free.</p>

<p>When we apply this closure to the value 2, we must replace the free occurrences in line 3 but leave those in line 2 unchanged.</p>

<p>The substitution algorithm is implemented in the following function - which is a typical syntax-driven function, which traverses a list of ASTs, and recursively transforms the nodes.  The only expression type where an actual transformation is performed is <code class="language-plaintext highlighter-rouge">VarRef</code>.</p>

<p>Observe how the code of the transformation is similar to the code of <code class="language-plaintext highlighter-rouge">applyEnv</code> we discussed in the previous lecture.</p>

<p>When traversing a proc-exp within the body (as in the example we just reviewed above), substitute removes from the list
of variables to be substituted the variables which are now bound by the new var-decls of the proc-exp.
This is performed with the call to filter.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @Pre: vars and exps have the same length</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">substitute</span> <span class="o">=</span> <span class="p">(</span><span class="nx">body</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">[],</span> <span class="nx">vars</span><span class="p">:</span> <span class="kr">string</span><span class="p">[],</span> <span class="nx">exps</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">[]):</span> <span class="nx">CExp</span><span class="p">[]</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">subVarRef</span> <span class="o">=</span> <span class="p">(</span><span class="na">e</span><span class="p">:</span> <span class="nx">VarRef</span><span class="p">):</span> <span class="nx">CExp</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">pos</span> <span class="o">=</span> <span class="nx">indexOf</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="kd">var</span><span class="p">,</span> <span class="nx">vars</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">((</span><span class="nx">pos</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">?</span> <span class="nx">exps</span><span class="p">[</span><span class="nx">pos</span><span class="p">]</span> <span class="p">:</span> <span class="nx">e</span><span class="p">);</span>
    <span class="p">};</span>
    
    <span class="kd">const</span> <span class="nx">subProcExp</span> <span class="o">=</span> <span class="p">(</span><span class="na">e</span><span class="p">:</span> <span class="nx">ProcExp</span><span class="p">):</span> <span class="nx">ProcExp</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">argNames</span> <span class="o">=</span> <span class="nx">map</span><span class="p">((</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="kd">var</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">subst</span> <span class="o">=</span> <span class="nx">zip</span><span class="p">(</span><span class="nx">vars</span><span class="p">,</span> <span class="nx">exps</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">freeSubst</span> <span class="o">=</span> <span class="nx">filter</span><span class="p">((</span><span class="nx">ve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">includes</span><span class="p">(</span><span class="nx">first</span><span class="p">(</span><span class="nx">ve</span><span class="p">),</span> <span class="nx">argNames</span><span class="p">),</span> <span class="nx">subst</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">makeProcExp</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">args</span><span class="p">,</span> <span class="nx">substitute</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span> 
                                              <span class="nx">map</span><span class="p">((</span><span class="na">x</span><span class="p">:</span> <span class="nx">KeyValuePair</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="nx">CExp</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">freeSubst</span><span class="p">),</span> 
                                              <span class="nx">map</span><span class="p">((</span><span class="na">x</span><span class="p">:</span> <span class="nx">KeyValuePair</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="nx">CExp</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">freeSubst</span><span class="p">)));</span>
    <span class="p">};</span>
    
    <span class="kd">const</span> <span class="nx">sub</span> <span class="o">=</span> <span class="p">(</span><span class="na">e</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">):</span> <span class="nx">CExp</span> <span class="o">=&gt;</span> <span class="nx">isNumExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">e</span> <span class="p">:</span>
        <span class="nx">isBoolExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">e</span> <span class="p">:</span>
        <span class="nx">isPrimOp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">e</span> <span class="p">:</span>
        <span class="nx">isLitExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">e</span> <span class="p">:</span>
        <span class="nx">isStrExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">e</span> <span class="p">:</span>
        <span class="nx">isVarRef</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">subVarRef</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">:</span>
        <span class="nx">isIfExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeIfExp</span><span class="p">(</span><span class="nx">sub</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">test</span><span class="p">),</span> <span class="nx">sub</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">then</span><span class="p">),</span> <span class="nx">sub</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">alt</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">isProcExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">subProcExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">:</span>
        <span class="nx">isAppExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeAppExp</span><span class="p">(</span><span class="nx">sub</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">rator</span><span class="p">),</span> <span class="nx">map</span><span class="p">(</span><span class="nx">sub</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">rands</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">e</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="nx">map</span><span class="p">(</span><span class="nx">sub</span><span class="p">,</span> <span class="nx">body</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="avoid-capturing-free-variables-during-substitution">Avoid Capturing Free Variables During Substitution</h3>

<p>Consider the following program:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">z</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>

<span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">z</span><span class="p">)))</span> <span class="c1">; 1</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">w</span><span class="p">)</span> <span class="p">(</span><span class="nf">z</span> <span class="nv">w</span><span class="p">)))</span>             <span class="c1">; 2</span>
 <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>If we apply the substitution model as presented so far when computing the 2nd expression - we replace <code class="language-plaintext highlighter-rouge">x</code> with the 
expression <code class="language-plaintext highlighter-rouge">(lambda (w) (z w))</code> (which is the parameter passed as the <code class="language-plaintext highlighter-rouge">x</code> argument in line 1).</p>

<p>The resulting substituted body is:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">z</span><span class="p">)</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">w</span><span class="p">)</span> <span class="p">(</span><span class="nf">z</span> <span class="nv">w</span><span class="p">))</span> <span class="nv">z</span><span class="p">))</span>
</code></pre></div></div>

<p>The problem in this substitution is that the inner var-ref <code class="language-plaintext highlighter-rouge">z</code> coming from the function <code class="language-plaintext highlighter-rouge">(lambda (w) (z w))</code>
is now <strong>captured</strong> by the <code class="language-plaintext highlighter-rouge">(lambda (z) ...)</code> context in which we operated the substitution.</p>

<p>As a result, this <code class="language-plaintext highlighter-rouge">z</code> var-ref now refers to the <code class="language-plaintext highlighter-rouge">(lambda (z) ...)</code> var-decl instead of referring to the global
<code class="language-plaintext highlighter-rouge">(define z ...)</code> var-decl as it should.</p>

<p>This effect is called <strong>free variable capture</strong> and we must avoid it.</p>

<p>The simplest solution to address this problem is to ensure that <strong>before we perform substitution</strong>, we 
<strong>rename consistently</strong> all the bound variables that occur in the body with fresh names.</p>

<p>This solution relies on the observation we mentioned in <a href="https://www.cs.bgu.ac.il/~ppl202/wiki.files/class/notebook/2.4SyntacticOperations.html">2.4 Syntactic Operations</a>
that the actual name of variables does not modify the semantics of expressions as long as their lexical address remains consistent.</p>

<p>The renaming algorithm is performed consistently through a syntax-driven traversal of the body AST.
It is implemented in the following manner in the interpreter. Note that the only type of expressions
which are transformed in this AST transformation are proc-exp constituents.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    Purpose: create a generator of new strings of the form v__n
    with n is incremented at each call. 
    Note the typical usage of a closure with side effect of the closed variable.
    
    Example:
    const gen = makeVarGen();
    console.log(gen("v")) =&gt; "v__1"
    console.log(gen("v")) =&gt; "v__2"
*/</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">makeVarGen</span> <span class="o">=</span> <span class="p">():</span> <span class="p">(</span><span class="nx">v</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="na">count</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="na">v</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nx">v</span><span class="p">}</span><span class="s2">__</span><span class="p">${</span><span class="nx">count</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
Purpose: Consistently rename bound variables in 'exps' to fresh names.
         Start numbering at 1 for all new var names.
Example: renameExps([parse("(lambda (x) ((lambda (x) x) (+ x x)))")])
  ==&gt; [(lambda (x__1) ((lambda (x__2) x__2) (+ x__1 x__1)))]
*/</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">renameExps</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exps</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">[]):</span> <span class="nx">CExp</span><span class="p">[]</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">varGen</span> <span class="o">=</span> <span class="nx">makeVarGen</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">replace</span> <span class="o">=</span> <span class="p">(</span><span class="na">e</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">):</span> <span class="nx">CExp</span> <span class="o">=&gt;</span>
        <span class="nx">isIfExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeIfExp</span><span class="p">(</span><span class="nx">replace</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">test</span><span class="p">),</span> <span class="nx">replace</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">then</span><span class="p">),</span> <span class="nx">replace</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">alt</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">isAppExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeAppExp</span><span class="p">(</span><span class="nx">replace</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">rator</span><span class="p">),</span> <span class="nx">map</span><span class="p">(</span><span class="nx">replace</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">rands</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">isProcExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">replaceProc</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">:</span>
        <span class="nx">e</span><span class="p">;</span>
    <span class="c1">// Rename the params and substitute old params with renamed ones.</span>
    <span class="c1">//  First recursively rename all ProcExps inside the body.</span>
    <span class="kd">const</span> <span class="nx">replaceProc</span> <span class="o">=</span> <span class="p">(</span><span class="na">e</span><span class="p">:</span> <span class="nx">ProcExp</span><span class="p">):</span> <span class="nx">ProcExp</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">oldArgs</span> <span class="o">=</span> <span class="nx">map</span><span class="p">((</span><span class="na">arg</span><span class="p">:</span> <span class="nx">VarDecl</span><span class="p">):</span> <span class="kr">string</span> <span class="o">=&gt;</span> <span class="nx">arg</span><span class="p">.</span><span class="kd">var</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">newArgs</span> <span class="o">=</span> <span class="nx">map</span><span class="p">(</span><span class="nx">varGen</span><span class="p">,</span> <span class="nx">oldArgs</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">newBody</span> <span class="o">=</span> <span class="nx">map</span><span class="p">(</span><span class="nx">replace</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">makeProcExp</span><span class="p">(</span><span class="nx">map</span><span class="p">(</span><span class="nx">makeVarDecl</span><span class="p">,</span> <span class="nx">newArgs</span><span class="p">),</span>
                           <span class="nx">substitute</span><span class="p">(</span><span class="nx">newBody</span><span class="p">,</span> <span class="nx">oldArgs</span><span class="p">,</span> <span class="nx">map</span><span class="p">(</span><span class="nx">makeVarRef</span><span class="p">,</span> <span class="nx">newArgs</span><span class="p">)));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">map</span><span class="p">(</span><span class="nx">replace</span><span class="p">,</span> <span class="nx">exps</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="the-apply-procedure-summarized">The Apply Procedure Summarized</h3>

<p>Putting all elements discussed above together, the apply-proc procedure implements the following algorithm:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">L3applyProcedure</span> <span class="o">=</span> <span class="p">(</span><span class="nx">proc</span><span class="p">:</span> <span class="nx">Value</span><span class="p">,</span> <span class="nx">args</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[],</span> <span class="nx">env</span><span class="p">:</span> <span class="nx">Env</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">isPrimOp</span><span class="p">(</span><span class="nx">proc</span><span class="p">)</span> <span class="p">?</span> <span class="nx">applyPrimitive</span><span class="p">(</span><span class="nx">proc</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isClosure</span><span class="p">(</span><span class="nx">proc</span><span class="p">)</span> <span class="p">?</span> <span class="nx">applyClosure</span><span class="p">(</span><span class="nx">proc</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">env</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">makeFailure</span><span class="p">(</span><span class="dl">"</span><span class="s2">Bad procedure </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">proc</span><span class="p">));</span>

<span class="kd">const</span> <span class="nx">applyClosure</span> <span class="o">=</span> <span class="p">(</span><span class="nx">proc</span><span class="p">:</span> <span class="nx">Closure</span><span class="p">,</span> <span class="nx">args</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[],</span> <span class="nx">env</span><span class="p">:</span> <span class="nx">Env</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">vars</span> <span class="o">=</span> <span class="nx">map</span><span class="p">((</span><span class="na">v</span><span class="p">:</span> <span class="nx">VarDecl</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="kd">var</span><span class="p">,</span> <span class="nx">proc</span><span class="p">.</span><span class="nx">params</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">renameExps</span><span class="p">(</span><span class="nx">proc</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">litArgs</span> <span class="o">=</span> <span class="nx">map</span><span class="p">(</span><span class="nx">valueToLitExp</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">evalSequence</span><span class="p">(</span><span class="nx">substitute</span><span class="p">(</span><span class="nx">body</span><span class="p">,</span> <span class="nx">vars</span><span class="p">,</span> <span class="nx">litArgs</span><span class="p">),</span> <span class="nx">env</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When evaluating a procedure call:</p>
<ol>
  <li>we make sure the body is renamed so that we avoid capturing free variables</li>
  <li>we map arguments to lit-exps</li>
  <li>then we perform the substitution</li>
</ol>

<p>When describing the apply procedure operation, we use the following terminology:</p>
<ul>
  <li>Substitute formal parameters</li>
  <li>Reduce (evaluate the substituted body)</li>
</ul>

<h2 id="renaming-and-substitution-operations">Renaming and Substitution Operations</h2>

<p>Let us review the properties of the two operations we defined over ASTs: Renaming and Substitution.</p>

<h3 id="renaming">Renaming</h3>

<p>Bound variables in expressions can be consistently renamed by new variables (that do not occur in the expression) without changing the intended meaning of the expression. That is, expressions that differ only by consistent renaming of bound variables are considered equivalent.</p>

<p>For example, the following are equivalent pairs:</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">==&gt;</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x1</span><span class="p">)</span> <span class="nv">x1</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="p">(</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">4</span><span class="p">))</span> <span class="nv">==&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="p">(</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x1</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1">;; Incorrect renaming:</span>
<span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="p">(</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">4</span><span class="p">))</span> <span class="nv">==&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x1</span> <span class="p">(</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x1</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<p>Compare this operation of renaming with the Lexical Address transformation we defined in <a href="https://bguppl.github.io/interpreters/class_material/class_material/2.4SyntacticOperations.html">Section 2.4</a>.
If we transform an expression <code class="language-plaintext highlighter-rouge">E1</code> and its renamed version <code class="language-plaintext highlighter-rouge">rename(E1)</code> into lexical address notation and remove the names of the variables <code class="language-plaintext highlighter-rouge">(x depth pos)</code> - we will obtain identical expressions.</p>

<h3 id="substitution">Substitution</h3>

<p>Substitute is an operation which replaces <em>free occurrences of variable references</em> in an expression by other expressions.</p>

<p><strong>Definition</strong>: A substitution <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="15" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> is a mapping from a finite set of variables to a finite set of expressions.</p>

<p>Substitutions are denoted using set notation. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{x = 3, y = a, z = #t, w = (lambda (x) (+ x 1))} 
is a substitution

{x = 3, x = a, z = #t, w = (lambda (x) (+ x 1))} 
is not a substitution because the variable x is mapped to 2 distinct values.
</code></pre></div></div>

<p>In these expressions, we denote expressions in their unparsed form instead of the more verbose AST form - but remember that substitutions map variable names to expressions.  For example,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{x = 3, y = a, z = #t}
</code></pre></div></div>

<p>really denotes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{x = (num-exp 3), y = (lit-exp a), z = (bool-exp #t)}
</code></pre></div></div>

<h4 id="composition-combination-of-substitutions">Composition (combination) of Substitutions</h4>

<p>The composition of substitutions <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="16" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> and <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="17" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2032"></mjx-c></mjx-mo></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>s</mi><mo data-mjx-alternate="1">′</mo></msup></math></mjx-assistive-mml></mjx-container>, denoted <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="18" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2032"></mjx-c></mjx-mo></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo>∘</mo><msup><mi>s</mi><mo data-mjx-alternate="1">′</mo></msup></math></mjx-assistive-mml></mjx-container>, is a substitution <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="19" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2033"></mjx-c></mjx-mo></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>s</mi><mo data-mjx-alternate="1">″</mo></msup></math></mjx-assistive-mml></mjx-container> that extends <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="20" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> with a binding
<code class="language-plaintext highlighter-rouge">&lt;x; s'(x)&gt;</code> for every variable <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="21" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml></mjx-container> for which <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="22" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> is not defined.</p>

<p>For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{x = 3, y = a} o {z = #t, w = (lambda (x) (+ x 1))} =
{x = 3, y = a, z = #t, w = (lambda (x) (+ x 1))}
</code></pre></div></div>

<p>The empty substitution {} is the neutral element of the substitution-composition operation: 
For every substitution <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="23" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container>, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="24" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7B"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c7D"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c7B"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c7D"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mo fence="false" stretchy="false">}</mo><mo>∘</mo><mi>s</mi><mo>=</mo><mi>s</mi><mo>∘</mo><mo fence="false" stretchy="false">{</mo><mo fence="false" stretchy="false">}</mo><mo>=</mo><mi>s</mi></math></mjx-assistive-mml></mjx-container>.</p>

<h4 id="substitution-application">Substitution Application</h4>

<p>By definition, The substitute operation consists of applying a substitution <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="25" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> to an expression <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="26" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container>. 
This operation is denoted <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="27" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi><mo>∘</mo><mi>s</mi></math></mjx-assistive-mml></mjx-container> (or just <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="28" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi><mi>s</mi></math></mjx-assistive-mml></mjx-container> if no confusion arises), and involves replacing 
free variable occurrences in <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="29" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> by other expressions. Substitution is performed in two steps:</p>
<ol>
  <li>Consistent renaming of the expression <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="30" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> and the expressions in <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="31" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container>.</li>
  <li>Simultaneous replacement of all free occurrences of the variables of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="32" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> in the renamed <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="33" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> by the corresponding renamed expressions of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="34" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container>.</li>
</ol>

<h3 id="substitution-examples">Substitution Examples</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">10 o {x = 5} = 10</code>: No renaming; no replacement.</li>
  <li><code class="language-plaintext highlighter-rouge">(+ x y) o {x = 5} = (+ 5 y)</code>: No renaming; just replacement.</li>
  <li><code class="language-plaintext highlighter-rouge">(+ x y) o {x = 5, y = 'x} = (+ 5 'x)</code>: No renaming; just replacement.</li>
  <li><code class="language-plaintext highlighter-rouge">((+ x ((lambda (x) (+ x 3)) 4))) o {x = 5} = </code>
    <ol>
      <li>Renaming: <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="35" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> turns into <code class="language-plaintext highlighter-rouge">((+ x ((lambda (x1) (+ x1 3)) 4)))</code></li>
      <li>Substitute: <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="36" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> turns into <code class="language-plaintext highlighter-rouge">((+ 5 ((lambda (x1) (+ x1 3)) 4)))</code></li>
    </ol>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">(lambda (y) (((lambda (x) x) y) x)) o {x = (lambda (x) (y x))} =</code>:</p>

    <p>Variable y in the substitution is free. It should stay free after the substitution application.</p>
    <ol>
      <li>Renaming: The substitution turns into <code class="language-plaintext highlighter-rouge">{x = (lambda (x1) (y x1))}</code>;
 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="37" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> turns into <code class="language-plaintext highlighter-rouge">(lambda (y2) (((lambda (x3) x3) y2) x))</code></li>
      <li>Substitute: <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="38" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> turns into <code class="language-plaintext highlighter-rouge">(lambda (y2) ( ((lambda (x3) x3) y2) (lambda (x1) (y x1)))</code></li>
    </ol>
  </li>
</ul>

<p>Observe: What would be the result without renaming? 
Note the difference in the binding status of the variable <code class="language-plaintext highlighter-rouge">y</code>.</p>

<p><strong>NOTE</strong>: In manual derivation exercies, if we observe there is no need for renaming, we skip the renaming step.
For example:</p>

<p><code class="language-plaintext highlighter-rouge">((+ x ((lambda (x) (+ x 3)) 4))) o {x = 5} = ((+ 5 ((lambda (x) (+ x 3)) 4)))</code></p>

<h3 id="applicative-eval-examples">Applicative Eval Examples</h3>

<p>Let us trace the evaluation of the applicative eval algorithm on the following <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="39" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> program:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">L2</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">square</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">sum-of-squares</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum-of-squares</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="mi">2</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">f</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">;; 136</span>
</code></pre></div></div>

<p>We skip the evaluation of the three def-exp expressions, which bind the variables to closures - 
and trace the evaluation of <code class="language-plaintext highlighter-rouge">(f 5)</code>:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">f</span> <span class="mi">5</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">f</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum-of-squares</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span><span class="nv">&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">5</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">5</span>
<span class="nv">==&gt;</span>
<span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">sum-of-squares</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">))</span> <span class="p">]</span> <span class="nv">==&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span><span class="nf">sum-of-squares</span><span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">y</span><span class="p">))</span><span class="nv">&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">+</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">+&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">5</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">5</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">1</span>
    <span class="nv">==&gt;</span> <span class="mi">6</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">*</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">*&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">5</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">5</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">2</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">2</span>
    <span class="nv">==&gt;</span> <span class="mi">10</span>
<span class="nv">==&gt;</span>
<span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">10</span><span class="p">))</span> <span class="p">]</span> <span class="nv">==&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">+</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">+&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">6</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">square</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span><span class="nv">&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">6</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">6</span>
    <span class="nv">==&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">6</span> <span class="mi">6</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">*</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">*&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">6</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">6</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">6</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">6</span>
    <span class="nv">==&gt;</span> <span class="mi">36</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">square</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span><span class="nv">&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">10</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">10</span>
    <span class="nv">==&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">10</span> <span class="mi">10</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">*</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;primitive-procedure</span> <span class="nv">*&gt;</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">10</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">10</span>
        <span class="nv">applicative-eval</span><span class="p">[</span> <span class="mi">10</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">10</span>
    <span class="nv">==&gt;</span> <span class="mi">100</span>
<span class="nv">==&gt;</span> <span class="mi">136</span>
</code></pre></div></div>

<h4 id="example-with-renaming">Example with Renaming</h4>

<p>Let us trace the evaluation of the following program:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">L2</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">y</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">g</span><span class="p">)</span> 
              <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">y</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">h</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">f</span> <span class="nv">h</span><span class="p">))</span> 
<span class="nv">==&gt;</span> 
<span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">y1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y1</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">y1</span><span class="p">))</span><span class="nv">&gt;</span>
</code></pre></div></div>

<p>Trace of the algorithm:</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">h</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">f</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">g</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">y</span><span class="p">)))</span><span class="nv">&gt;</span>
    <span class="nv">applicative-eval</span><span class="p">[</span> <span class="nv">h</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span><span class="nv">&gt;</span>
<span class="nv">==&gt;</span>
<span class="nv">Substitute</span> <span class="err">–</span> <span class="nv">rename</span> <span class="nv">both</span> <span class="nv">expressions</span> <span class="nv">and</span> <span class="nv">replace:</span>
    <span class="nv">Map</span> <span class="nv">the</span> <span class="nv">closure</span> <span class="nv">value</span> <span class="nv">of</span> <span class="nv">f</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">corresponding</span> <span class="nv">lambda</span> <span class="nv">expression</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y2</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">y2</span><span class="p">)))</span> <span class="nv">o</span> <span class="err">{</span><span class="nv">g</span> <span class="nv">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x1</span> <span class="nv">y</span><span class="p">))</span><span class="err">}</span>
<span class="nv">==&gt;</span>
<span class="nv">Reduce</span> <span class="nv">-</span> <span class="nv">applicative-eval</span><span class="p">[</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y2</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x1</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">y2</span> <span class="p">)</span> <span class="p">))</span> <span class="p">]</span>
<span class="nv">==&gt;</span>
<span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">y2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y2</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x1</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">y2</span><span class="p">)</span> <span class="p">)</span> <span class="nv">&gt;</span>
</code></pre></div></div>

<p>Renaming plays here an essential role. Without it, the application <code class="language-plaintext highlighter-rouge">((f h) 3)</code> would
replace all free occurrences of <code class="language-plaintext highlighter-rouge">y</code> by 3, yielding 9 as the result, instead of 10 - the correct value when the inner
<code class="language-plaintext highlighter-rouge">y</code> variable reference remains bound to the global var-decl of <code class="language-plaintext highlighter-rouge">y</code> to 4.</p>

<h2 id="parameter-passing-mode-by-value">Parameter Passing Mode: By Value</h2>

<p>The substitution model – applicative order uses the call-by-value method for parameter passing.</p>

<p>This is the standard evaluation model in Scheme, and the most frequent method in other languages as well (JavaScript, C++, Java).</p>

<h2 id="l3-compound-values-and-quoted-literal-expressions"><mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="40" style="font-size: 117.3%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>3</mn></math></mjx-assistive-mml></mjx-container>: Compound Values and Quoted Literal Expressions</h2>

<p>Let us extend <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="41" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>2</mn></math></mjx-assistive-mml></mjx-container> with support for compound values, leading to the definition of the <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="42" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>3</mn></math></mjx-assistive-mml></mjx-container> language.</p>

<p>In this language, the AST is extentend with new primitives to support compound values (lists),
we also introduce a special value for the empty list (<code class="language-plaintext highlighter-rouge">'()</code>) which the parser must recognize and support for compound literal expressions: up to this point, the only literal expressions we supported were numbers, strings and booleans.</p>

<p>The expanded AST for <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="43" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>3</mn></math></mjx-assistive-mml></mjx-container> is:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">;;</span> <span class="o">&lt;</span><span class="nx">program</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span><span class="nx">L3</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;+</span><span class="p">)</span> <span class="c1">// program(exps:List(exp))</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="nx">define</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="nx">define</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span><span class="nx">define</span> <span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">decl</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;</span><span class="p">)</span> <span class="c1">// def-exp(var:var-decl, val:cexp)</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">&lt;</span><span class="nx">num</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="c1">// num-exp(val:Number)</span>
<span class="p">;;</span>        <span class="o">|</span> <span class="o">&lt;</span><span class="nx">bool</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span>  <span class="c1">// bool-exp(val:Boolean)</span>
<span class="p">;;</span>        <span class="o">|</span> <span class="o">&lt;</span><span class="nx">prim</span><span class="o">-</span><span class="nx">op</span><span class="o">&gt;</span>   <span class="c1">// prim-op(op:string)</span>
<span class="p">;;</span>        <span class="o">|</span> <span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">ref</span><span class="o">&gt;</span>   <span class="c1">// var-ref(var:string)</span>
<span class="p">;;</span>        <span class="o">|</span> <span class="p">(</span><span class="k">if</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">exp</span><span class="o">&gt;</span><span class="p">)</span> <span class="c1">// if-exp(test,then,else)                                   ## L2</span>
<span class="p">;;</span>        <span class="o">|</span> <span class="p">(</span><span class="nx">lambda</span> <span class="p">(</span><span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">decl</span><span class="o">&gt;*</span><span class="p">)</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;+</span><span class="p">)</span> <span class="c1">// proc-exp(params:List(var-decl), body:List(cexp)) ## L2</span>
<span class="p">;;</span>        <span class="o">|</span> <span class="p">(</span><span class="nx">quote</span> <span class="o">&lt;</span><span class="nx">sexp</span><span class="o">&gt;</span><span class="p">)</span> <span class="c1">// lit-exp(val:Sexp)                                                ##### L3</span>
<span class="p">;;</span>        <span class="o">|</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">cexp</span><span class="o">&gt;*</span><span class="p">)</span> <span class="c1">// app-exp(rator:cexp, rands:List(cexp))</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="nx">prim</span><span class="o">-</span><span class="nx">op</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="o">+</span> <span class="o">|</span> <span class="o">-</span> <span class="o">|</span> <span class="o">*</span> <span class="o">|</span> <span class="sr">/ | &lt; | &gt; | = | not |  and  |  or  |  eq</span><span class="se">?</span><span class="err"> 
</span><span class="p">;;</span>        <span class="o">|</span> <span class="nx">cons</span> <span class="o">|</span> <span class="nx">car</span> <span class="o">|</span> <span class="nx">cdr</span> <span class="o">|</span> <span class="nx">pair</span><span class="p">?</span> <span class="o">|</span> <span class="nx">list</span><span class="p">?</span> <span class="o">|</span> <span class="kr">number</span><span class="p">?</span> <span class="o">|</span> <span class="nx">boolean</span><span class="p">?</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">?</span>                    <span class="err">#####</span> <span class="nx">L3</span>
<span class="p">;;</span>        <span class="o">|</span> <span class="nx">display</span> <span class="o">|</span> <span class="nx">newline</span>                                                                  <span class="err">#####</span> <span class="nx">L3</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="nx">num</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nx">a</span> <span class="kr">number</span> <span class="nx">token</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="nx">bool</span><span class="o">-</span><span class="nx">exp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="err">#</span><span class="nx">t</span> <span class="o">|</span> <span class="err">#</span><span class="nx">f</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">ref</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nx">an</span> <span class="nx">identifier</span> <span class="nx">token</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="kd">var</span><span class="o">-</span><span class="nx">decl</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nx">an</span> <span class="nx">identifier</span> <span class="nx">token</span>
<span class="p">;;</span> <span class="o">&lt;</span><span class="nx">sexp</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">=</span> <span class="nx">a</span> <span class="nx">symbol</span> <span class="nx">token</span> <span class="o">|</span> <span class="p">(</span> <span class="o">&lt;</span><span class="nx">sexp</span><span class="o">&gt;*</span> <span class="p">)</span> <span class="o">|</span> <span class="p">(</span> <span class="o">&lt;</span><span class="nx">sexp</span><span class="o">&gt;</span> <span class="p">.</span> <span class="o">&lt;</span><span class="nx">sexp</span><span class="o">&gt;</span> <span class="p">)</span>                               <span class="err">#####</span> <span class="nx">L3</span>

</code></pre></div></div>

<p>The main additions in <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="44" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>3</mn></math></mjx-assistive-mml></mjx-container> is the fact that the set of computed values now includes complex composite values (lists).
The set of computed values is now:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Value</span> <span class="o">=</span> <span class="nb">Number</span> <span class="o">|</span> <span class="nb">Boolean</span> <span class="o">|</span> <span class="nx">Prim</span><span class="o">-</span><span class="nx">op</span> <span class="o">|</span> <span class="nx">Closure</span> <span class="o">|</span> <span class="nx">Void</span> <span class="o">|</span> <span class="nx">SExp</span>
<span class="nx">SExp</span> <span class="o">=</span> <span class="nb">Symbol</span> <span class="o">|</span> <span class="nb">Number</span> <span class="o">|</span> <span class="nb">Boolean</span> <span class="o">|</span> <span class="nx">EmptySExp</span> <span class="o">|</span> <span class="nx">Pair</span><span class="p">(</span><span class="nx">SExp</span><span class="p">,</span> <span class="nx">SExp</span><span class="p">)</span>
</code></pre></div></div>

<p>To support these composite datatypes, we introduce value constructors and accessors as primitives (<code class="language-plaintext highlighter-rouge">cons, car, cdr</code>) and
the corresponding type predicates as primitives as well (<code class="language-plaintext highlighter-rouge">pair?, list?, symbol?</code>) and equality predicate (<code class="language-plaintext highlighter-rouge">eq?</code>) which must be capable to recognize the empty-list value.
We also introduce side effect primitives (<code class="language-plaintext highlighter-rouge">display</code> and <code class="language-plaintext highlighter-rouge">newline</code>).</p>

<p>The empty list special value (which is a value which is not a number, not a boolean and not a symbol) must be supported in the syntax.</p>

<p>The last modification we introduce is to support literal expressions for the new compound values.
We use the Scheme <strong>quote</strong> special operator to support these.  An expression:</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">quote</span> <span class="nv">&lt;sexp&gt;</span><span class="p">)</span>
</code></pre></div></div>
<p>is a special expression which is computed according to the following computation rule:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span><span class="p">((</span><span class="nx">quote</span> <span class="o">&lt;</span><span class="nx">sexp</span><span class="o">&gt;</span><span class="p">))</span> <span class="o">=&gt;</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">sexp</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>For example:</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">quote</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="ss">'a</span>
<span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="o">'</span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span>
</code></pre></div></div>

<p>The special form <code class="language-plaintext highlighter-rouge">(quote &lt;sexp&gt;)</code> is written in Scheme in a shorthand notation <code class="language-plaintext highlighter-rouge">'&lt;sexp&gt;</code> - for example, <code class="language-plaintext highlighter-rouge">'a</code> for a symbol
or <code class="language-plaintext highlighter-rouge">'(a b)</code> for a list.</p>

<p>To support the apply-procedure and substitution of values back as expressions, we took care in the procedure to turn values into expressions with a special case for Literal Expressions that wrap SExp values:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">valueToLitExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">v</span><span class="p">:</span> <span class="nx">Value</span><span class="p">):</span> <span class="nx">NumExp</span> <span class="o">|</span> <span class="nx">BoolExp</span> <span class="o">|</span> <span class="nx">StrExp</span> <span class="o">|</span> <span class="nx">LitExp</span> <span class="o">|</span> <span class="nx">PrimOp</span> <span class="o">|</span> <span class="nx">ProcExp</span> <span class="o">=&gt;</span>
    <span class="nx">isNumber</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeNumExp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isBoolean</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeBoolExp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isString</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeStrExp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isPrimOp</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">v</span> <span class="p">:</span>
    <span class="nx">isClosure</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeProcExp</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">params</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">body</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">makeLitExp</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</code></pre></div></div>

<p>Since SExps are not a type that exists in TypeScript, we must implement this type as part of the possible values computed by <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="45" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>3</mn></math></mjx-assistive-mml></mjx-container>.  This is implemented in the definition of the L3-Value module:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ========================================================</span>
<span class="c1">// SExp</span>
<span class="k">export</span> <span class="kd">type</span> <span class="nx">CompoundSExp</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">CompoundSexp</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">val1</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">;</span>
    <span class="nl">val2</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">export</span> <span class="kd">type</span> <span class="nx">EmptySExp</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">EmptySExp</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">export</span> <span class="kd">type</span> <span class="nx">SymbolSExp</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">SymbolSExp</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">val</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">type</span> <span class="nx">SExpValue</span> <span class="o">=</span> <span class="kr">number</span> <span class="o">|</span> <span class="nx">boolean</span> <span class="o">|</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">PrimOp</span> <span class="o">|</span> <span class="nx">Closure</span> <span class="o">|</span> <span class="nx">SymbolSExp</span> <span class="o">|</span> <span class="nx">EmptySExp</span> <span class="o">|</span> <span class="nx">CompoundSExp</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">isSExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">x</span> <span class="k">is</span> <span class="nx">SExpValue</span> <span class="o">=&gt;</span>
    <span class="k">typeof</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span> <span class="o">||</span> <span class="k">typeof</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">boolean</span><span class="dl">'</span> <span class="o">||</span> <span class="k">typeof</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span> <span class="o">||</span>
    <span class="nx">isSymbolSExp</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isCompoundSExp</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isEmptySExp</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isPrimOp</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isClosure</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">makeCompoundSExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val1</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">,</span> <span class="nx">val2</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">):</span> <span class="nx">CompoundSExp</span> <span class="o">=&gt;</span>
    <span class="p">({</span><span class="na">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">CompoundSexp</span><span class="dl">"</span><span class="p">,</span> <span class="na">val1</span><span class="p">:</span> <span class="nx">val1</span><span class="p">,</span> <span class="na">val2</span> <span class="p">:</span> <span class="nx">val2</span><span class="p">});</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">isCompoundSExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">x</span> <span class="k">is</span> <span class="nx">CompoundSExp</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">CompoundSexp</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">makeEmptySExp</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">EmptySExp</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">EmptySExp</span><span class="dl">"</span><span class="p">});</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">isEmptySExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">x</span> <span class="k">is</span> <span class="nx">EmptySExp</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">EmptySExp</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">makeSymbolSExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">SymbolSExp</span> <span class="o">=&gt;</span>
    <span class="p">({</span><span class="na">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">SymbolSExp</span><span class="dl">"</span><span class="p">,</span> <span class="na">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">});</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">isSymbolSExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">x</span> <span class="k">is</span> <span class="nx">SymbolSExp</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">SymbolSExp</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>The SExp datatype must also be supported in the parser for <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="46" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>3</mn></math></mjx-assistive-mml></mjx-container> - so that we expand the L3-AST module with support for parsing SExp values and returning quoted SExp values accordingly.
This is supported in the following function:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In L3-AST</span>

<span class="c1">// sexps has the shape (quote &lt;sexp&gt;)</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">parseLitExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">param</span><span class="p">:</span> <span class="nx">Sexp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">LitExp</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">mapv</span><span class="p">(</span><span class="nx">parseSExp</span><span class="p">(</span><span class="nx">param</span><span class="p">),</span> <span class="p">(</span><span class="nx">sexp</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">)</span> <span class="o">=&gt;</span> 
         <span class="nx">makeLitExp</span><span class="p">(</span><span class="nx">sexp</span><span class="p">));</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">isDottedPair</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sexps</span><span class="p">:</span> <span class="nx">Sexp</span><span class="p">[]):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span>
    <span class="nx">sexps</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> 
    <span class="nx">sexps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">makeDottedPair</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sexps</span> <span class="p">:</span> <span class="nx">Sexp</span><span class="p">[]):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">SExpValue</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">parseSExp</span><span class="p">(</span><span class="nx">sexps</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="nx">val1</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">)</span> <span class="o">=&gt;</span> 
        <span class="nx">mapv</span><span class="p">(</span><span class="nx">parseSExp</span><span class="p">(</span><span class="nx">sexps</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="p">(</span><span class="nx">val2</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">)</span> <span class="o">=&gt;</span>
             <span class="nx">makeCompoundSExp</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span> <span class="nx">val2</span><span class="p">)));</span>

<span class="c1">// x is the output of p (sexp parser)</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">parseSExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sexp</span><span class="p">:</span> <span class="nx">Sexp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">SExpValue</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">sexp</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">#t</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">sexp</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">#f</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isString</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isNumericString</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="o">+</span><span class="nx">sexp</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isSexpString</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="nx">sexp</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span> <span class="p">:</span>
    <span class="nx">isString</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="nx">makeSymbolSExp</span><span class="p">(</span><span class="nx">sexp</span><span class="p">))</span> <span class="p">:</span>
    <span class="nx">sexp</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="nx">makeEmptySExp</span><span class="p">())</span> <span class="p">:</span>
    <span class="nx">isDottedPair</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeDottedPair</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isArray</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)</span> <span class="p">?</span> <span class="p">(</span>
        <span class="c1">// fail on (x . y z)</span>
        <span class="nx">sexp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">.</span><span class="dl">'</span> <span class="p">?</span> <span class="nx">makeFailure</span><span class="p">(</span><span class="s2">`Bad dotted sexp: </span><span class="p">${</span><span class="nx">sexp</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span> <span class="p">:</span> 
        <span class="nx">bind</span><span class="p">(</span><span class="nx">parseSExp</span><span class="p">(</span><span class="nx">first</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)),</span> <span class="p">(</span><span class="nx">val1</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">)</span> <span class="o">=&gt;</span>
             <span class="nx">mapv</span><span class="p">(</span><span class="nx">parseSExp</span><span class="p">(</span><span class="nx">rest</span><span class="p">(</span><span class="nx">sexp</span><span class="p">)),</span> <span class="p">(</span><span class="nx">val2</span><span class="p">:</span> <span class="nx">SExpValue</span><span class="p">)</span> <span class="o">=&gt;</span>
                  <span class="nx">makeCompoundSExp</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span> <span class="nx">val2</span><span class="p">)))</span> 
        <span class="p">)</span> <span class="p">:</span>
    <span class="nx">sexp</span><span class="p">;</span>
</code></pre></div></div>

<p>The interpreter which implements all of the changes is available in:</p>
<ul>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L3/L3-ast.ts">L3 AST</a> - Abstract syntax and parser including literal expressions</li>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L3/L3-value.ts">L3 Value</a> - Definition of values (SExp and Closures)</li>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L3/L3-env.ts">L3 Env</a> - Environment (empty and extended)</li>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L3/L3-eval.ts">L3 Eval</a> - Interpreter</li>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L3/evalPrimitive.ts">evalPrimitive</a> - Type safe evaluation of primitive calls</li>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L3/substitute.ts">substitute</a> - substitute and rename algorithms</li>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/test/L3/L3.test.ts">L3.Tests</a> - Tests</li>
</ul>

<p>With this interpreter, we can write programs such as the following - many examples are shown in the Tests:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">L3</span> <span class="p">(</span><span class="k">define</span> <span class="nv">empty?</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq?</span> <span class="nv">x</span> <span class="o">'</span><span class="p">())))</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">filter</span>
      <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">pred</span> <span class="nv">l</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">l</span><span class="p">)</span>
            <span class="nv">l</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">pred</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">l</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nf">filter</span> <span class="nv">pred</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">l</span><span class="p">)))</span>
                      <span class="p">(</span><span class="nf">filter</span> <span class="nv">pred</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">l</span><span class="p">))))))</span>
    <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">)))</span>
</code></pre></div></div>

<h2 id="error-handling">Error Handling</h2>

<p>Both the parser and the interpreter of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="47" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>3</mn></math></mjx-assistive-mml></mjx-container> handle possible errors - either in the syntax of the program to be parsed or in the semantics of the program, that is, the interpreter must be capable of detecting an error at runtime and to report this error properly.</p>

<p>We implement error handler in the parser using the Result<t> monad approach:</t></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">parseL3</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">Program</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>That is, the parser either returns a valid <code class="language-plaintext highlighter-rouge">Program</code> result wrapped in an Ok<program> value or a Failure.
Similarly, we define the interpreter with the following signature:</program></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">L3applicativeEval</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">,</span> <span class="nx">env</span><span class="p">:</span> <span class="nx">Env</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>That is, the interpreter can obtain as parameter a valid CExp, and it returns either an OK Value or a Failure.
We must make sure the interpreter is never passed a Failure value in one of the recursive calls.<br>
This is ensured by consistently adopting the pattern of <code class="language-plaintext highlighter-rouge">bind(&lt;call returning a Result&lt;Value&gt; &gt;, (value: Value) =&gt; continuation)</code></p>

<p>This means that we do <strong>not</strong> change the definition of the AST data type or the Value data type to include Error as a possible values.
There are two reasons for this decision:</p>
<ul>
  <li>Errors are not <em>real</em> ASTs or Values - they are semantically outside the domains of the syntax and the interpreter.</li>
  <li>Errors are <strong>absorbing</strong> elements of the interpreter.</li>
</ul>

<p>Absorbing means that if we <em>compose</em> an Error with any other value when interpreting a compound expression, then the whole value must become an Error - regardless of the rules of evaluation of the expression (whether it is a special form or an application).
For example, consider the rule of evaluation of an IfExp expression: it is a <em>special form</em> - that is, not all sub-expressions are evaluated before the value of the compound IfExp is computed.  The semantic definition is:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">To</span> <span class="nb">eval</span><span class="p">:</span> <span class="nx">IfExp</span><span class="p">(</span><span class="nx">then</span><span class="p">,</span> <span class="k">else</span><span class="p">,</span> <span class="nx">alt</span><span class="p">)</span> <span class="k">in</span> <span class="nx">env</span><span class="p">:</span>
   <span class="k">if</span> <span class="nx">isTruValue</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nx">then</span><span class="p">,</span> <span class="nx">env</span><span class="p">))</span> <span class="nx">then</span>
       <span class="nb">eval</span><span class="p">(</span><span class="nx">then</span><span class="p">,</span> <span class="nx">env</span><span class="p">)</span>
   <span class="k">else</span>
       <span class="nb">eval</span><span class="p">(</span><span class="nx">alt</span><span class="p">,</span> <span class="nx">env</span><span class="p">)</span>
</code></pre></div></div>

<p>With error processing, the definition is implemented using the <code class="language-plaintext highlighter-rouge">bind</code> pattern:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">evalIf</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="nx">IfExp</span><span class="p">,</span> <span class="nx">env</span><span class="p">:</span> <span class="nx">Env</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">L3applicativeEval</span><span class="p">(</span><span class="nx">exp</span><span class="p">.</span><span class="nx">test</span><span class="p">,</span> <span class="nx">env</span><span class="p">),</span> <span class="p">(</span><span class="nx">test</span><span class="p">:</span> <span class="nx">Value</span><span class="p">)</span> <span class="o">=&gt;</span> 
         <span class="nx">isTrueValue</span><span class="p">(</span><span class="nx">test</span><span class="p">)</span> <span class="p">?</span> <span class="nx">L3applicativeEval</span><span class="p">(</span><span class="nx">exp</span><span class="p">.</span><span class="nx">then</span><span class="p">,</span> <span class="nx">env</span><span class="p">)</span> <span class="p">:</span> 
         <span class="nx">L3applicativeEval</span><span class="p">(</span><span class="nx">exp</span><span class="p">.</span><span class="nx">alt</span><span class="p">,</span> <span class="nx">env</span><span class="p">));</span>
</code></pre></div></div>

<p>We first test whether the evaluation of the exp.test sub-expression returns an error.  If it is the case, the whole expression is reduced to this error - without evaluating any of the sub-expressions exp.then or exp.alt.</p>

<p>Similarly, when evaluating an application expression (AppExp) - the semantic rule is:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">To</span> <span class="nb">eval</span><span class="p">:</span> <span class="nx">AppExp</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span> <span class="nx">rands</span><span class="p">)</span> <span class="k">in</span> <span class="nx">env</span><span class="p">:</span>
   <span class="kd">let</span> <span class="nx">proc</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span> <span class="nx">env</span><span class="p">)</span>
       <span class="nx">args</span> <span class="o">=</span> <span class="nx">map</span><span class="p">(</span><span class="nb">eval</span><span class="p">,</span> <span class="nx">rands</span><span class="p">)</span>
       <span class="nx">applyProc</span><span class="p">(</span><span class="nx">proc</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
</code></pre></div></div>

<p>With error processing, the processing is expanded into:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">isAppExp</span><span class="p">(</span><span class="nx">exp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">L3applicativeEval</span><span class="p">(</span><span class="nx">exp</span><span class="p">.</span><span class="nx">rator</span><span class="p">,</span> <span class="nx">env</span><span class="p">),</span> <span class="p">(</span><span class="nx">rator</span><span class="p">:</span> <span class="nx">Value</span><span class="p">)</span> <span class="o">=&gt;</span>
                         <span class="nx">bind</span><span class="p">(</span><span class="nx">mapResult</span><span class="p">(</span><span class="nx">param</span> <span class="o">=&gt;</span> <span class="nx">L3applicativeEval</span><span class="p">(</span><span class="nx">param</span><span class="p">,</span> <span class="nx">env</span><span class="p">),</span> <span class="nx">exp</span><span class="p">.</span><span class="nx">rands</span><span class="p">),</span> <span class="p">(</span><span class="nx">rands</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[])</span> <span class="o">=&gt;</span>
                              <span class="nx">L3applyProcedure</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span> <span class="nx">rands</span><span class="p">,</span> <span class="nx">env</span><span class="p">)))</span> <span class="p">:</span>
</code></pre></div></div>

<p>In addition to the general <code class="language-plaintext highlighter-rouge">bind</code> and <code class="language-plaintext highlighter-rouge">mapv</code> patterns which push a <code class="language-plaintext highlighter-rouge">Result&lt;T&gt;</code> value into a diagonal function <code class="language-plaintext highlighter-rouge">T -&gt; Result&lt;T&gt;</code> or a flat function <code class="language-plaintext highlighter-rouge">T -&gt; T</code>, we also introduce the <code class="language-plaintext highlighter-rouge">mapResult</code> function:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">mapResult</code> applies a procedure <code class="language-plaintext highlighter-rouge">f</code> of type <code class="language-plaintext highlighter-rouge">[T1 =&gt; Result&lt;T2&gt;]</code> to an array <code class="language-plaintext highlighter-rouge">T1[]</code> and executes <code class="language-plaintext highlighter-rouge">f</code> on each of the elements of the array.  If one of them returns a Failure, this failure is returned, else an Ok wrapper of the array of results is returned.</li>
  <li><code class="language-plaintext highlighter-rouge">mapResult</code> is a safe version of <code class="language-plaintext highlighter-rouge">map</code> for functions that can return a Failure. It does not return an array <code class="language-plaintext highlighter-rouge">Result&lt;T2&gt;[]</code> but instead a value of type <code class="language-plaintext highlighter-rouge">Result&lt;T2[]&gt;</code>.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">bind</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">r</span><span class="p">:</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">f</span><span class="p">:</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">isOk</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">?</span> <span class="nx">f</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="p">:</span> <span class="nx">r</span><span class="p">;</span>

<span class="c1">// bind a result value into a happy path function that does not fail</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">mapv</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">r</span><span class="p">:</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">f</span><span class="p">:</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">isOk</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span> <span class="p">:</span> <span class="nx">r</span><span class="p">;</span>

<span class="c1">// Purpose: Like map on an array - but when the transformer function applied returns a Result&lt;T&gt;</span>
<span class="c1">//          With f: T=&gt;Result&lt;U&gt; and list: T[] return a Result&lt;U[]&gt; </span>
<span class="c1">//          If one of the items of the list fails on f - returns the Failure on the first item that fails.</span>
<span class="c1">// Example: </span>
<span class="c1">// mapResult((x) =&gt; x === 0 ? makeFailure("div by 0") : makeOk(1/x), [1,2]) ==&gt; {tag:"Ok", value:[1, 0.5]}</span>
<span class="c1">// mapResult((x) =&gt; x === 0 ? makeFailure("div by 0") : makeOk(1/x), [1,0,2]) ==&gt; {tag:"Failure", message:"div by 0"}</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">mapResult</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">f</span><span class="p">:</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">list</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">U</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">isEmpty</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">([])</span> <span class="p">:</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">first</span><span class="p">(</span><span class="nx">list</span><span class="p">)),</span> 
         <span class="p">(</span><span class="nx">fa</span><span class="p">:</span> <span class="nx">U</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">mapResult</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">list</span><span class="p">)),</span> 
                         <span class="p">(</span><span class="nx">fas</span><span class="p">:</span> <span class="nx">U</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="nx">makeOk</span><span class="p">(</span><span class="nx">cons</span><span class="p">(</span><span class="nx">fa</span><span class="p">,</span> <span class="nx">fas</span><span class="p">))));</span>
</code></pre></div></div>

<p>The net result of guarding against errors at all stages of the parsing and evaluation process allows us to handle errors in a proper manner <strong>without using exception</strong> in the meta-language.<br>
We do not throw exceptions.  Instead, we return Result<t> values, and properly guard against composing Failure values against other types of values along the whole evaluation process.</t></p>

<p>This is an important methodological point: we can implement a process of evaluation which is in essence equivalent to throwing exceptions <strong>without requiring exceptions</strong> in the meta-language.  In a sense, we have <em>explained</em> what throwing an exception would mean in the semantic domain by enforcing the fact that <code class="language-plaintext highlighter-rouge">Failure</code> is an absorbing element for all semantic operations that operate over <code class="language-plaintext highlighter-rouge">Result&lt;Value&gt;</code>.</p>

<h2 id="normal-order-evaluation-algorithm">Normal Order Evaluation Algorithm</h2>

<p><code class="language-plaintext highlighter-rouge">applicative-eval</code> implements an <strong>eager approach</strong> in evaluation: arguments are evaluated immediately, before the closure is reduced.</p>

<p>An alternative algorithm implements a <strong>lazy approach</strong> in evaluation: it avoids evaluating arguments until the last moment it is necessary. When is a value necessary in the evaluation process?</p>
<ol>
  <li>When we need to decide a computation branch.</li>
  <li>When we need to apply a primitive procedure.</li>
</ol>

<p>The <strong>normal evaluation algorithm</strong> is similar to the applicative-eval we have just reviewed. 
The only difference, which leads to the lazy approach, moves the step of argument evaluation 
just before a primitive procedure is applied. Otherwise, the algorithm is unchanged, and the 
computation rules for the special operators are the same.</p>

<p>This is a remarkably small change in the algorithm with a deep change to the way the language behaves.</p>

<p>To describe the Normal Order evaluation algorithm, we only need to change a single evaluation rule - that for application expressions:</p>

<p>The applicative-eval form we first saw is:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">applicative</span><span class="o">-</span><span class="nb">eval</span><span class="p">(</span><span class="nx">app</span><span class="o">-</span><span class="nx">exp</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span> <span class="nx">rands</span><span class="p">))</span> <span class="o">=&gt;</span>
    <span class="c1">// rator is of type cexp</span>
    <span class="c1">// rands is of type List(cexp)</span>
    <span class="kd">let</span> <span class="nx">proc</span> <span class="o">=</span> <span class="nx">applicative</span><span class="o">-</span><span class="nb">eval</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span><span class="nx">env</span><span class="p">)</span>
        <span class="p">;;</span> <span class="nx">First</span> <span class="nx">evaluate</span> <span class="nx">parameters</span>
        <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="nx">applicative</span><span class="o">-</span><span class="nb">eval</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span><span class="nx">env</span><span class="p">)</span> <span class="k">for</span> <span class="nx">r</span> <span class="k">in</span> <span class="nx">rands</span><span class="p">]</span>
        <span class="p">;;</span> <span class="nx">Then</span> <span class="nx">invoke</span> <span class="nx">the</span> <span class="nx">procedure</span> <span class="nx">on</span> <span class="nx">the</span> <span class="nx">values</span>
        <span class="k">return</span> <span class="nx">apply</span><span class="o">-</span><span class="nx">proc</span><span class="p">(</span><span class="nx">proc</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
</code></pre></div></div>

<p>To obtain the normal order lazy strategy, we change the evaluation rule to the following:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">normal</span><span class="o">-</span><span class="nb">eval</span><span class="p">(</span><span class="nx">app</span><span class="o">-</span><span class="nx">exp</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span> <span class="nx">rands</span><span class="p">))</span> <span class="o">=&gt;</span>
    <span class="c1">// rator is of type cexp</span>
    <span class="c1">// rands is of type List(cexp)</span>
    <span class="kd">let</span> <span class="nx">proc</span> <span class="o">=</span> <span class="nx">normal</span><span class="o">-</span><span class="nb">eval</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span><span class="nx">env</span><span class="p">)</span>
        <span class="p">;;</span> <span class="nx">invoke</span> <span class="nx">the</span> <span class="nx">procedure</span> <span class="nx">on</span> <span class="nx">the</span> <span class="nx">arguments</span> <span class="nx">WITHOUT</span> <span class="nx">evaluating</span> <span class="nx">them</span>
        <span class="k">return</span> <span class="nx">normal</span><span class="o">-</span><span class="nx">apply</span><span class="o">-</span><span class="nx">proc</span><span class="p">(</span><span class="nx">proc</span><span class="p">,</span> <span class="nx">rands</span><span class="p">)</span>
</code></pre></div></div>

<p>The apply procedure process must be adapted to this slight change:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">normal</span><span class="o">-</span><span class="nx">apply</span><span class="o">-</span><span class="nx">proc</span><span class="p">(</span><span class="nx">proc</span><span class="p">:</span> <span class="nx">Closure</span><span class="p">,</span> <span class="nx">rands</span><span class="p">:</span> <span class="nx">CExp</span><span class="p">[]):</span> <span class="nx">Value</span>
    <span class="k">if</span> <span class="nx">proc</span> <span class="k">is</span> <span class="nx">a</span> <span class="nx">primitive</span><span class="p">:</span>
        <span class="p">;;</span> <span class="nx">We</span> <span class="nx">must</span> <span class="nx">evaluate</span> <span class="nx">all</span> <span class="nx">the</span> <span class="nx">args</span> <span class="nx">to</span> <span class="nx">apply</span> <span class="nx">a</span> <span class="nx">primitive</span>
        <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="nx">normal</span><span class="o">-</span><span class="nb">eval</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="k">for</span> <span class="nx">r</span> <span class="k">in</span> <span class="nx">rands</span><span class="p">]</span>
            <span class="k">return</span> <span class="nx">apply</span><span class="o">-</span><span class="nx">primitive</span><span class="p">(</span><span class="nx">proc</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
    <span class="k">else</span> <span class="c1">// proc is a closure</span>
        <span class="c1">// Substitute the rands and reduce</span>
        <span class="kd">let</span> <span class="nx">subst</span><span class="o">-</span><span class="nx">body</span> <span class="o">=</span> <span class="nx">substitute</span> <span class="nx">params</span> <span class="k">in</span> <span class="nx">body</span> <span class="k">of</span> <span class="nx">proc</span> <span class="kd">with</span> <span class="nx">rands</span>
            <span class="k">return</span> <span class="nx">normal</span><span class="o">-</span><span class="nb">eval</span><span class="p">(</span><span class="nx">subst</span><span class="o">-</span><span class="nx">body</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that we do not need to turn the values back into expression before we apply the substitution in the body,
since the rands are passed as non-evaluated expressions.</p>

<p>The code of the normal-evaluation interpreter is available in:</p>
<ul>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L3/L3-normal.ts">L3 Normal Evaluation</a></li>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/test/L3/L3-normal.test.ts">L3 Normal Tests</a></li>
</ul>

<h4 id="normal-evaluation-example">Normal Evaluation Example</h4>

<p>Let us consider the normal evaluation of the same example as above:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">square</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">sum-of-squares</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">y</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum-of-squares</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; 136</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">f</span> <span class="mi">5</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
    <span class="nv">normal-eval</span><span class="p">[</span><span class="nf">f</span><span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum-of-squares</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="mi">2</span><span class="p">))</span><span class="nv">&gt;</span>
    <span class="nv">==&gt;</span>
    <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">sum-of-squares</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">))</span> <span class="p">]</span> <span class="nv">==&gt;</span>
        <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">sum-of-squares</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">y</span><span class="p">))</span><span class="nv">&gt;</span>
    <span class="nv">==&gt;</span>
    <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)))</span> <span class="p">]</span> <span class="nv">==&gt;</span>
        <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">+</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">+&gt;</span>
        <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">))</span> <span class="p">]</span> <span class="nv">==&gt;</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">square</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span><span class="nv">&gt;</span>
            <span class="nv">==&gt;</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">))</span> <span class="p">]</span> <span class="nv">==&gt;</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">*</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">*&gt;</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">+</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">+&gt;</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="mi">5</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">5</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">1</span>
            <span class="nv">==&gt;</span> <span class="mi">6</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">+</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">+&gt;</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="mi">5</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">5</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">1</span>
            <span class="nv">==&gt;</span> <span class="mi">6</span>
        <span class="nv">==&gt;</span> <span class="mi">36</span>
        <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">))</span> <span class="p">]</span> <span class="nv">==&gt;</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">square</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;Closure</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span><span class="nv">&gt;</span>
            <span class="nv">==&gt;</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">))</span> <span class="p">]</span> <span class="nv">==&gt;</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">*</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">*&gt;</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">*</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">*&gt;</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="mi">5</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">5</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="mi">2</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">2</span>
            <span class="nv">==&gt;</span> <span class="mi">10</span>
            <span class="nv">normal-eval</span><span class="p">[</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="p">]</span> <span class="nv">==&gt;</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="nv">*</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="nv">&lt;prim-op</span> <span class="nv">*&gt;</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="mi">5</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">5</span>
                <span class="nv">normal-eval</span><span class="p">[</span> <span class="mi">2</span> <span class="p">]</span> <span class="nv">==&gt;</span> <span class="mi">2</span>
            <span class="nv">==&gt;</span> <span class="mi">10</span>
        <span class="nv">==&gt;</span> <span class="mi">100</span>
    <span class="nv">==&gt;</span> <span class="mi">136</span>
</code></pre></div></div>

<p>Observe how the same computations are <strong>repeated</strong> in the normal evaluation algorithm, while they were processed only once in applicative order: for example <code class="language-plaintext highlighter-rouge">(* 5 2)</code> when it is passed to the function <code class="language-plaintext highlighter-rouge">square</code> is not computed before the substitution into the body of <code class="language-plaintext highlighter-rouge">square</code> - which leads to the computation of <code class="language-plaintext highlighter-rouge">(* (* 5 2) (* 5 2))</code> in normal order instead of <code class="language-plaintext highlighter-rouge">(* 10 10)</code> in applicative order.</p>

<h3 id="normal-order-parameter-passing-mode-call-by-name">Normal Order Parameter Passing Mode: Call by Name</h3>

<p>The normal order strategy of passing arguments to procedures without pre-computing them is called <strong>call by name</strong> - as opposed to the <strong>call by value</strong> defined by applicative-eval.</p>

<p>Normal-order evaluation is also called <strong>lazy evaluation</strong> because it delays the evaluation of arguments to the last moment when it is needed.</p>

<h2 id="comparison-applicative-order-vs-normal-order-evaluation">Comparison Applicative Order vs. Normal Order Evaluation</h2>

<p>Normal order and applicative order are different algorithms applied to expressions in order to compute their value.
Do they compute the same values?</p>

<p>The <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem">Church Rosser Theorem</a> is a fundamental result in lambda calculus which states that:  when applying reduction rules to terms in the lambda calculus, the ordering in which the reductions are chosen does not make a difference to the eventual result. More precisely, if there are two distinct reductions or sequences of reductions that can be applied to the same term, then there exists a term that is reachable from both results, by applying (possibly empty) sequences of additional reductions.  <a href="https://www.irif.fr/~mellies/mpri/mpri-ens/biblio/Selinger-Lambda-Calculus-Notes.pdf">Lecture Notes on the Lambda Calculus</a> (Selinger, 2013) provides a readable formal proof of this theorem (Read up to Section 4.4, p.36).</p>

<p>In the context of the substitution model of the operational semantics of our language which is a variant of Lambda Calculus rewriting, the Church Rosser theorem leads to the following statement:</p>

<p><strong>If both applicative-eval and normal-eval terminate (compute a value without an infinite loop and without exceptions), then they compute the same value.</strong></p>

<p>More precisely, the differences between applicative-eval and normal-eval are:</p>
<ol>
  <li>If both orders terminate (no infinite loop and no exception): They compute the same value.</li>
  <li>Normal order evaluation may repeat computations which applicative-eval does not.</li>
  <li>Whenever applicative order evaluation terminates, normal order terminates as well.</li>
  <li>There are expressions where normal order evaluation terminates, while applicative order does not</li>
  <li>Side effects (like printing) are executed in different ways by applicative-eval and normal-eval - this fact can be used to identify the evaluation order of an interpreter. In applicative order, side-effects included in parameters will be executed only once before the reduction step; in normal order, these side-effects can be executed 0 to many times - depending on the logic of the execution, and in different orders than what is executed in applicative-order.</li>
</ol>

<h4 id="different-behavior-on-loops">Different behavior on loops</h4>

<p>Consider the example:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nx">L3</span>
    <span class="p">(</span><span class="nx">define</span> <span class="nx">loop</span> <span class="p">(</span><span class="nx">lambda</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">(</span><span class="nx">loop</span> <span class="nx">x</span><span class="p">)))</span>
    <span class="p">(</span><span class="nx">define</span> <span class="nx">g</span> <span class="p">(</span><span class="nx">lambda</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="mi">5</span><span class="p">))</span>
    <span class="p">(</span><span class="nx">g</span> <span class="p">(</span><span class="nx">loop</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></div></div>

<p>In normal order, the application <code class="language-plaintext highlighter-rouge">(loop 0)</code> is not evaluated. 
In applicative order: the call <code class="language-plaintext highlighter-rouge">(g (loop 0))</code> enters into an infinite loop.</p>

<h4 id="different-behavior-on-exceptions">Different behavior on exceptions</h4>

<p>Consider the example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">L3</span> 
    <span class="p">(</span><span class="k">define</span> <span class="nv">try</span> 
        <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> 
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">)</span>
                <span class="mi">1</span>
                <span class="nv">b</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">try</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></div></div>

<p>In normal order, this program returns 1.
In applicative order, it throws a <code class="language-plaintext highlighter-rouge">divide by 0</code> exception.</p>

<h4 id="different-behavior-on-side-effects">Different behavior on side effects</h4>

<p>Consider, for example,</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">L3</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">display</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">newline</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">g</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="mi">5</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">g</span> <span class="p">(</span><span class="nf">f</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></div></div>

<p>With applicative-eval, this program prints <code class="language-plaintext highlighter-rouge">0</code> then returns <code class="language-plaintext highlighter-rouge">5</code>.
In contrast, in normal-eval, this program returns 5 <strong>without printing</strong> anything.</p>

<h2 id="summary">Summary</h2>

<h3 id="applicative-eval-algorithm">Applicative Eval Algorithm</h3>

<ul>
  <li>The definition of the evaluation rule for if-expressions relies is a special evaluation rule: only 2 of the 3 components of the if-expression are evaluated; In order to determine whether the value of the condition is true for the test, a function <code class="language-plaintext highlighter-rouge">true-value?</code> determines which values are considered true in the language.  This part of the semantic specification of the language changes from language to language (compare Scheme and JavaScript for example).</li>
  <li>The evaluation rule for lambda-expressions (procedures) is also a special form.  None of the 2 components of the form are evaluated.  Instead, they are packaged as-is into a new value type called a <strong>closure</strong>.  No computation is performed at closure-creation time.  Instead, the body of the closure will be evaluated when the closure is applied to actual parameters.</li>
  <li>The key complexity of supporting user-defined procedures holds in the definition of the <strong>apply-procedure</strong> process. We defined the process of <strong>call by value</strong> - also called <strong>applicative eval</strong>: arguments to a procedure are first recursively evaluated; then the values are passed to the procedure.</li>
  <li>To apply a closure value to values, we defined the <strong>substitution operation</strong> which replaces all free occurrences of variables with simple expressions (number, boolean, lambda or literal expressions).</li>
  <li>To avoid capturing free variables by error, we apply a substitution to the body of a closure only after all <strong>bound variables in the body have been consistently renamed</strong>.</li>
</ul>

<h3 id="substitution-1">Substitution</h3>
<ul>
  <li>Substitute is an operation which replaces free occurrences of variable references in an expression by other expressions.</li>
  <li>A substitution <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="48" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> is a mapping from a finite set of variables to a finite set of expressions.</li>
  <li>A substitution <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="49" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> can be applied to an expression <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="50" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> to produce a new expression <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="51" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em; margin-left: 0.051em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2032"></mjx-c></mjx-mo></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>E</mi><mo data-mjx-alternate="1">′</mo></msup><mo>=</mo><mi>E</mi><mo>∘</mo><mi>s</mi></math></mjx-assistive-mml></mjx-container>. values.</li>
  <li>Substitution is performed in two steps:
    <ul>
      <li>Consistent renaming of the expression <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="52" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> and the expressions in <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="53" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container>.</li>
      <li>Simultaneous replacement of all free occurrences of the variables of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="54" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> in the renamed <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="55" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container> by the corresponding renamed expressions of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="56" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container>.</li>
    </ul>
  </li>
  <li>2 substitutions <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="57" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> and <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="58" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2032"></mjx-c></mjx-mo></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>s</mi><mo data-mjx-alternate="1">′</mo></msup></math></mjx-assistive-mml></mjx-container> can be composed into a new substitution <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="59" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2033"></mjx-c></mjx-mo></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2032"></mjx-c></mjx-mo></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>s</mi><mo data-mjx-alternate="1">″</mo></msup><mo>=</mo><mi>s</mi><mo>∘</mo><msup><mi>s</mi><mo data-mjx-alternate="1">′</mo></msup></math></mjx-assistive-mml></mjx-container> such that for all expression <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="60" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi></math></mjx-assistive-mml></mjx-container>,
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="61" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2033"></mjx-c></mjx-mo></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c5B"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c5D"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em;"><mjx-mo class="mjx-var" size="s"><mjx-c class="mjx-c2032"></mjx-c></mjx-mo></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>E</mi><mo>∘</mo><msup><mi>s</mi><mo data-mjx-alternate="1">″</mo></msup><mo>=</mo><mo stretchy="false">[</mo><mi>E</mi><mo>∘</mo><mi>s</mi><mo stretchy="false">]</mo><mo>∘</mo><msup><mi>s</mi><mo data-mjx-alternate="1">′</mo></msup></math></mjx-assistive-mml></mjx-container>.</li>
</ul>

<h3 id="supporting-compound-values">Supporting Compound Values</h3>
<ul>
  <li>To support compound values, like lists and pairs, in the language, we introduce:
    <ul>
      <li>new primitives (cons, car, cdr, pair?, list?)</li>
      <li>a new syntactic form to support literal symbols and compound expressions (introduced by the quote operator in Scheme) and the special empty-list value</li>
      <li>and new Value types for empty-list and SExpressions.</li>
    </ul>
  </li>
  <li>The evaluation rule for literal-expressions <code class="language-plaintext highlighter-rouge">(quote &lt;val&gt;)</code> (also written in Scheme as <code class="language-plaintext highlighter-rouge">'&lt;val&gt;</code>) is to return the corresponding value <code class="language-plaintext highlighter-rouge">&lt;val&gt;</code>.</li>
</ul>

<h3 id="normal-evaluation">Normal Evaluation</h3>
<ul>
  <li>applicative-eval implements an eager approach to evaluation: arguments are evaluated immediately, before the procedure is reduced.</li>
  <li><code class="language-plaintext highlighter-rouge">normal-eval</code> implements a lazy approach to evaluation: it avoids evaluating arguments until the last moment it is necessary:
    <ul>
      <li>When we need to decide a computation branch.</li>
      <li>When we need to apply a primitive procedure.</li>
    </ul>
  </li>
  <li>The only difference between <code class="language-plaintext highlighter-rouge">normal-eval</code> and <code class="language-plaintext highlighter-rouge">applicative-eval</code> is the handling of parameters in <code class="language-plaintext highlighter-rouge">apply-procedure</code>:
    <ul>
      <li>In applicative-eval, we first evaluate the parameters, then substitute, then reduce.</li>
      <li>In normal-eval, we substitute the parameters non-evaluated, then reduce.</li>
    </ul>
  </li>
  <li>Mathematical results in <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="62" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D706 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D462 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D462 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>λ</mi><mo>−</mo><mi>c</mi><mi>a</mi><mi>l</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>u</mi><mi>s</mi></math></mjx-assistive-mml></mjx-container> demonstrate that:
    <ul>
      <li>If an expression can be reduced to a value (that is, the program returns a value without entering in loops or throwing exceptions), the normal-eval algorithm will return this value.</li>
      <li>In some cases, applicative-eval may enter in a loop or throw exceptions in cases where normal-eval would find the value.</li>
      <li>If applicative-eval returns a value, it is the same one as that returned by normal-eval.</li>
    </ul>
  </li>
  <li>Usually, applicative-eval is more efficient than normal eval, as it executes sub-expressions less times than the normal-eval.</li>
</ul>



        <footer class="site-footer">
            
            <span class="site-footer-owner"><a href="https://github.com/bguppl/interpreters">interpreters</a> is maintained by <a href="https://github.com/bguppl">bguppl</a>.</span>
            
            <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com/">GitHub
                    Pages</a>.</span>
        </footer>
    </main>


<div id="give-freely-root-ejkiikneibegknkgimmihdpcbcedgmpo" class="give-freely-root" data-extension-id="ejkiikneibegknkgimmihdpcbcedgmpo" data-extension-name="Volume Booster" style="display: block;"><template shadowrootmode="open"><style>
  :host {
    all: initial;
  }

  .gf-scroll-remove::-webkit-scrollbar {
    border-radius-bottom-right: 15px;
  }

  button {
    cursor: pointer;
    transition: transform 0.1s ease;
  }

  button:active {
    transform: scale(0.98);
  }

  .give-freely-close-button:hover {
    opacity: 0.7;
  }

  input[type="radio"] {
    margin-right: 8px;
  }

  hr {
    border: none;
    border-top: 1px solid #e5e5e5;
    margin: 1em 0;
  }

  @media (max-width: 600px), (max-height: 480px) {
    #give-freely-checkout-popup {
      display: none !important;
    }
  }
</style><div><div class="gf-app"></div></div></template></div></body></html>