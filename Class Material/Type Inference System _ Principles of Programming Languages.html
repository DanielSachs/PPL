<!DOCTYPE html>
<!-- saved from url=(0080)https://bguppl.github.io/interpreters/class_material/3.3TypeInferenceSystem.html -->
<html lang=" en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="module" id="truffle-injected" data-runtime="bkkjeefjfjcfdfifddmkdmcpmaakmelp" src="chrome-extension://bkkjeefjfjcfdfifddmkdmcpmaakmelp/injected-script/index.js"></script>

    
    

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Type Inference System | Principles of Programming Languages</title>
<meta name="generator" content="Jekyll v3.10.0">
<meta property="og:title" content="Type Inference System">
<meta property="og:locale" content="en_US">
<meta name="description" content="Course Website">
<meta property="og:description" content="Course Website">
<link rel="canonical" href="https://bguppl.github.io/interpreters/class_material/3.3TypeInferenceSystem.html">
<meta property="og:url" content="https://bguppl.github.io/interpreters/class_material/3.3TypeInferenceSystem.html">
<meta property="og:site_name" content="Principles of Programming Languages">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Type Inference System">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Course Website","headline":"Type Inference System","url":"https://bguppl.github.io/interpreters/class_material/3.3TypeInferenceSystem.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com/">
    <link rel="preload" href="./Type Inference System _ Principles of Programming Languages_files/css" as="style" type="text/css" crossorigin="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="./Type Inference System _ Principles of Programming Languages_files/style.css">
<style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style><style id="MJX-CHTML-styles">
mjx-container[jax="CHTML"] {
  line-height: 0;
}

mjx-container [space="1"] {
  margin-left: .111em;
}

mjx-container [space="2"] {
  margin-left: .167em;
}

mjx-container [space="3"] {
  margin-left: .222em;
}

mjx-container [space="4"] {
  margin-left: .278em;
}

mjx-container [space="5"] {
  margin-left: .333em;
}

mjx-container [rspace="1"] {
  margin-right: .111em;
}

mjx-container [rspace="2"] {
  margin-right: .167em;
}

mjx-container [rspace="3"] {
  margin-right: .222em;
}

mjx-container [rspace="4"] {
  margin-right: .278em;
}

mjx-container [rspace="5"] {
  margin-right: .333em;
}

mjx-container [size="s"] {
  font-size: 70.7%;
}

mjx-container [size="ss"] {
  font-size: 50%;
}

mjx-container [size="Tn"] {
  font-size: 60%;
}

mjx-container [size="sm"] {
  font-size: 85%;
}

mjx-container [size="lg"] {
  font-size: 120%;
}

mjx-container [size="Lg"] {
  font-size: 144%;
}

mjx-container [size="LG"] {
  font-size: 173%;
}

mjx-container [size="hg"] {
  font-size: 207%;
}

mjx-container [size="HG"] {
  font-size: 249%;
}

mjx-container [width="full"] {
  width: 100%;
}

mjx-box {
  display: inline-block;
}

mjx-block {
  display: block;
}

mjx-itable {
  display: inline-table;
}

mjx-row {
  display: table-row;
}

mjx-row > * {
  display: table-cell;
}

mjx-mtext {
  display: inline-block;
}

mjx-mstyle {
  display: inline-block;
}

mjx-merror {
  display: inline-block;
  color: red;
  background-color: yellow;
}

mjx-mphantom {
  visibility: hidden;
}

_::-webkit-full-page-media, _:future, :root mjx-container {
  will-change: opacity;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-math {
  display: inline-block;
  text-align: left;
  line-height: 0;
  text-indent: 0;
  font-style: normal;
  font-weight: normal;
  font-size: 100%;
  font-size-adjust: none;
  letter-spacing: normal;
  border-collapse: collapse;
  word-wrap: normal;
  word-spacing: normal;
  white-space: nowrap;
  direction: ltr;
  padding: 1px 0;
}

mjx-container[jax="CHTML"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="CHTML"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="CHTML"][display="true"] mjx-math {
  padding: 0;
}

mjx-container[jax="CHTML"][justify="left"] {
  text-align: left;
}

mjx-container[jax="CHTML"][justify="right"] {
  text-align: right;
}

mjx-mi {
  display: inline-block;
  text-align: left;
}

mjx-c {
  display: inline-block;
}

mjx-utext {
  display: inline-block;
  padding: .75em 0 .2em 0;
}

mjx-mn {
  display: inline-block;
  text-align: left;
}

mjx-mo {
  display: inline-block;
  text-align: left;
}

mjx-stretchy-h {
  display: inline-table;
  width: 100%;
}

mjx-stretchy-h > * {
  display: table-cell;
  width: 0;
}

mjx-stretchy-h > * > mjx-c {
  display: inline-block;
  transform: scalex(1.0000001);
}

mjx-stretchy-h > * > mjx-c::before {
  display: inline-block;
  width: initial;
}

mjx-stretchy-h > mjx-ext {
  /* IE */ overflow: hidden;
  /* others */ overflow: clip visible;
  width: 100%;
}

mjx-stretchy-h > mjx-ext > mjx-c::before {
  transform: scalex(500);
}

mjx-stretchy-h > mjx-ext > mjx-c {
  width: 0;
}

mjx-stretchy-h > mjx-beg > mjx-c {
  margin-right: -.1em;
}

mjx-stretchy-h > mjx-end > mjx-c {
  margin-left: -.1em;
}

mjx-stretchy-v {
  display: inline-block;
}

mjx-stretchy-v > * {
  display: block;
}

mjx-stretchy-v > mjx-beg {
  height: 0;
}

mjx-stretchy-v > mjx-end > mjx-c {
  display: block;
}

mjx-stretchy-v > * > mjx-c {
  transform: scaley(1.0000001);
  transform-origin: left center;
  overflow: hidden;
}

mjx-stretchy-v > mjx-ext {
  display: block;
  height: 100%;
  box-sizing: border-box;
  border: 0px solid transparent;
  /* IE */ overflow: hidden;
  /* others */ overflow: visible clip;
}

mjx-stretchy-v > mjx-ext > mjx-c::before {
  width: initial;
  box-sizing: border-box;
}

mjx-stretchy-v > mjx-ext > mjx-c {
  transform: scaleY(500) translateY(.075em);
  overflow: visible;
}

mjx-mark {
  display: inline-block;
  height: 0px;
}

mjx-c::before {
  display: block;
  width: 0;
}

.MJX-TEX {
  font-family: MJXZERO, MJXTEX;
}

.TEX-B {
  font-family: MJXZERO, MJXTEX-B;
}

.TEX-I {
  font-family: MJXZERO, MJXTEX-I;
}

.TEX-MI {
  font-family: MJXZERO, MJXTEX-MI;
}

.TEX-BI {
  font-family: MJXZERO, MJXTEX-BI;
}

.TEX-S1 {
  font-family: MJXZERO, MJXTEX-S1;
}

.TEX-S2 {
  font-family: MJXZERO, MJXTEX-S2;
}

.TEX-S3 {
  font-family: MJXZERO, MJXTEX-S3;
}

.TEX-S4 {
  font-family: MJXZERO, MJXTEX-S4;
}

.TEX-A {
  font-family: MJXZERO, MJXTEX-A;
}

.TEX-C {
  font-family: MJXZERO, MJXTEX-C;
}

.TEX-CB {
  font-family: MJXZERO, MJXTEX-CB;
}

.TEX-FR {
  font-family: MJXZERO, MJXTEX-FR;
}

.TEX-FRB {
  font-family: MJXZERO, MJXTEX-FRB;
}

.TEX-SS {
  font-family: MJXZERO, MJXTEX-SS;
}

.TEX-SSB {
  font-family: MJXZERO, MJXTEX-SSB;
}

.TEX-SSI {
  font-family: MJXZERO, MJXTEX-SSI;
}

.TEX-SC {
  font-family: MJXZERO, MJXTEX-SC;
}

.TEX-T {
  font-family: MJXZERO, MJXTEX-T;
}

.TEX-V {
  font-family: MJXZERO, MJXTEX-V;
}

.TEX-VB {
  font-family: MJXZERO, MJXTEX-VB;
}

mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c {
  font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A ! important;
}

@font-face /* 0 */ {
  font-family: MJXZERO;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff");
}

@font-face /* 1 */ {
  font-family: MJXTEX;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff");
}

@font-face /* 2 */ {
  font-family: MJXTEX-B;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff");
}

@font-face /* 3 */ {
  font-family: MJXTEX-I;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff");
}

@font-face /* 4 */ {
  font-family: MJXTEX-MI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff");
}

@font-face /* 5 */ {
  font-family: MJXTEX-BI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff");
}

@font-face /* 6 */ {
  font-family: MJXTEX-S1;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff");
}

@font-face /* 7 */ {
  font-family: MJXTEX-S2;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff");
}

@font-face /* 8 */ {
  font-family: MJXTEX-S3;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff");
}

@font-face /* 9 */ {
  font-family: MJXTEX-S4;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff");
}

@font-face /* 10 */ {
  font-family: MJXTEX-A;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff");
}

@font-face /* 11 */ {
  font-family: MJXTEX-C;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff");
}

@font-face /* 12 */ {
  font-family: MJXTEX-CB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff");
}

@font-face /* 13 */ {
  font-family: MJXTEX-FR;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff");
}

@font-face /* 14 */ {
  font-family: MJXTEX-FRB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff");
}

@font-face /* 15 */ {
  font-family: MJXTEX-SS;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff");
}

@font-face /* 16 */ {
  font-family: MJXTEX-SSB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff");
}

@font-face /* 17 */ {
  font-family: MJXTEX-SSI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff");
}

@font-face /* 18 */ {
  font-family: MJXTEX-SC;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff");
}

@font-face /* 19 */ {
  font-family: MJXTEX-T;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff");
}

@font-face /* 20 */ {
  font-family: MJXTEX-V;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff");
}

@font-face /* 21 */ {
  font-family: MJXTEX-VB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff");
}

mjx-c.mjx-c1D43F.TEX-I::before {
  padding: 0.683em 0.681em 0 0;
  content: "L";
}

mjx-c.mjx-c35::before {
  padding: 0.666em 0.5em 0.022em 0;
  content: "5";
}

mjx-c.mjx-c1D460.TEX-I::before {
  padding: 0.442em 0.469em 0.01em 0;
  content: "s";
}

mjx-c.mjx-c28::before {
  padding: 0.75em 0.389em 0.25em 0;
  content: "(";
}

mjx-c.mjx-c1D447.TEX-I::before {
  padding: 0.677em 0.704em 0 0;
  content: "T";
}

mjx-c.mjx-c29::before {
  padding: 0.75em 0.389em 0.25em 0;
  content: ")";
}

mjx-c.mjx-c1D462.TEX-I::before {
  padding: 0.442em 0.572em 0.011em 0;
  content: "u";
}

mjx-c.mjx-c1D44F.TEX-I::before {
  padding: 0.694em 0.429em 0.011em 0;
  content: "b";
}

mjx-c.mjx-c1D45B.TEX-I::before {
  padding: 0.442em 0.6em 0.011em 0;
  content: "n";
}

mjx-c.mjx-c2B::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "+";
}

mjx-c.mjx-c31::before {
  padding: 0.666em 0.5em 0 0;
  content: "1";
}

mjx-c.mjx-c1D437.TEX-I::before {
  padding: 0.683em 0.828em 0 0;
  content: "D";
}

mjx-c.mjx-c2212::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "\2212";
}

mjx-c.mjx-c2C::before {
  padding: 0.121em 0.278em 0.194em 0;
  content: ",";
}

mjx-c.mjx-c1D441.TEX-I::before {
  padding: 0.683em 0.888em 0 0;
  content: "N";
}

mjx-c.mjx-c3D::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "=";
}

mjx-c.mjx-c30::before {
  padding: 0.666em 0.5em 0.022em 0;
  content: "0";
}
</style></head>

<body>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async="" src="./Type Inference System _ Principles of Programming Languages_files/tex-mml-chtml.js.download"></script>

    <header class="page-header" role="banner">
        <h1 class="project-name">Principles of Programming Languages</h1>
        <h2 class="project-tagline">Course Website</h2>
        
        <a href="https://github.com/bguppl/interpreters" class="btn">View on GitHub</a>
        
        
    </header>

    <main id="content" class="main-content" role="main">
        <h1 id="type-inference-system">Type Inference System</h1>
<h2 id="ppl-2021">PPL 2021</h2>

<p>In the previous lecture, we have introduced the Type Equations algorithm to perform Type Inference over Scheme (<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="0" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>5</mn></math></mjx-assistive-mml></mjx-container>) expressions.</p>

<p>In this lecture, we present two distinct implementations of this algorithm - one which is a “literal” application of the algorithm, and one which is an optimized transformation of the algorithm relying on more compact data structures and less traversals of the program.</p>

<h2 id="architecture-of-the-type-equations-inference-system">Architecture of the Type Equations Inference System</h2>

<p>The Type Inference with Type Equations system builds on the L5 AST abstract syntax defined for the Type Checker.
It introduces two new modules:</p>
<ul>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L5/L5-substitution-adt.ts">Substitution ADT</a></li>
  <li><a href="https://github.com/bguppl/interpreters/blob/master/src/L5/L5-type-equations.ts">Type Equations Algorithm</a></li>
</ul>

<h3 id="the-substitution-adt">The Substitution ADT</h3>

<p>The Substitution ADT is a direct implementation of the mathematical substitution object introduced in the previous lecture,
adjusted to work on type variables and type expressions.</p>

<h4 id="type-substitution-definition">Type Substitution Definition</h4>

<p>A type-substitution <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="1" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></mjx-assistive-mml></mjx-container> is a mapping from a finite set of type variables to a finite set of type expressions, such that <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="2" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> does not include <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="3" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></mjx-assistive-mml></mjx-container>.</p>

<p>As usual, when defining substitutions and partial functions (we have already implemented such data structures when talking about <strong>environments</strong>), 
we adopt an inductive implementation to define the Type Substitution data type, which is the union of two disjoint types:</p>
<ul>
  <li>The empty sustitution</li>
  <li>Non-empty substitutions: <code class="language-plaintext highlighter-rouge">sub(tvars: TVar[], texps: TExp[])</code></li>
</ul>

<p>The functional interface of the Substitution data type includes:</p>

<ul>
  <li>Value constructors for the empty substitution <code class="language-plaintext highlighter-rouge">makeEmptySub</code> and non-empty substitutions <code class="language-plaintext highlighter-rouge">sub(tvars, texps)</code>.</li>
  <li>Value constructor for composing two substitutions <code class="language-plaintext highlighter-rouge">subCombine(sub1, sub2)</code>.</li>
</ul>

<p>Both the functions <code class="language-plaintext highlighter-rouge">sub(tvars, texps)</code> and <code class="language-plaintext highlighter-rouge">subCombine(sub1, sub2)</code> return a non-empty substitution.
They also enforce the <strong>key invariant of substitutions</strong>: for any variable <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="4" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></mjx-assistive-mml></mjx-container>, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="5" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D462 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44F TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi><mi>u</mi><mi>b</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> does not include <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="6" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></mjx-assistive-mml></mjx-container>.</p>

<p>This invariant check is performed by the function <code class="language-plaintext highlighter-rouge">checkNoOccurrence(tvar, texp)</code>.
This function is a standard AST traversal of the Type expression <code class="language-plaintext highlighter-rouge">Texp</code> looking for any instance of the Type variable <code class="language-plaintext highlighter-rouge">Tvar</code> at any level.</p>

<p>This process is called <strong>occurrence check</strong> and is central to all unification based methods.
It is a computationally expensive component of the algorithm.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Purpose: when attempting to bind tvar to te in a sub - check whether tvar occurs in te.</span>
<span class="c1">// Return error if a circular reference is found.</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">checkNoOccurrence</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tvar</span><span class="p">:</span> <span class="nx">TVar</span><span class="p">,</span> <span class="nx">te</span><span class="p">:</span> <span class="nx">TExp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">check</span> <span class="o">=</span> <span class="p">(</span><span class="na">e</span><span class="p">:</span> <span class="nx">TExp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
        <span class="nx">isTVar</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="p">((</span><span class="nx">e</span><span class="p">.</span><span class="kd">var</span> <span class="o">===</span> <span class="nx">tvar</span><span class="p">.</span><span class="kd">var</span><span class="p">)</span> <span class="p">?</span> 
                       <span class="nx">bind</span><span class="p">(</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te</span><span class="p">),</span> 
                            <span class="nx">up</span> <span class="o">=&gt;</span> <span class="nx">makeFailure</span><span class="p">(</span><span class="s2">`Occur check error - circular sub </span><span class="p">${</span><span class="nx">tvar</span><span class="p">.</span><span class="kd">var</span><span class="p">}</span><span class="s2"> in </span><span class="p">${</span><span class="nx">up</span><span class="p">}</span><span class="s2">`</span><span class="p">))</span> <span class="p">:</span> 
                       <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">isAtomicTExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">:</span>
        <span class="nx">isProcTExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">mapResult</span><span class="p">(</span><span class="nx">check</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">paramTEs</span><span class="p">),</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">check</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">returnTE</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">makeFailure</span><span class="p">(</span><span class="s2">`Bad type expression </span><span class="p">${</span><span class="nx">e</span><span class="p">}</span><span class="s2"> in </span><span class="p">${</span><span class="nx">te</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">check</span><span class="p">(</span><span class="nx">te</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Similarly to environments, we define the non-empty substitution as a linked-list of bindings mapping variables to values. 
This value type is computed using the <code class="language-plaintext highlighter-rouge">extend-sub(sub,tvar,texp)</code> method.  Note that the method requires two “complications” in addition 
to extending the base-substitution with the new binding:</p>
<ol>
  <li>The existing right-hand-side of the base substitutions are updated with the new substitution (var-&gt;te)</li>
  <li>We perform occur check on the resulting substitution (by invoking make-sub which includes an occur-check).</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Purpose: extend a substitution with one pair (tv, te)</span>
<span class="c1">// Calls to makeSub to do the occur-check</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">extendSub</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sub</span><span class="p">:</span> <span class="nx">Sub</span><span class="p">,</span> <span class="nx">v</span><span class="p">:</span> <span class="nx">TVar</span><span class="p">,</span> <span class="nx">te</span><span class="p">:</span> <span class="nx">TExp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">Sub</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">makeSub</span><span class="p">([</span><span class="nx">v</span><span class="p">],</span> <span class="p">[</span><span class="nx">te</span><span class="p">]),</span> <span class="p">(</span><span class="nx">sub2</span><span class="p">:</span> <span class="nx">Sub</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">updatedTEs</span> <span class="o">=</span> <span class="nx">map</span><span class="p">((</span><span class="nx">te</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">applySub</span><span class="p">(</span><span class="nx">sub2</span><span class="p">,</span> <span class="nx">te</span><span class="p">),</span> <span class="nx">sub</span><span class="p">.</span><span class="nx">tes</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">includes</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="kd">var</span><span class="p">,</span> <span class="nx">map</span><span class="p">(</span><span class="nx">prop</span><span class="p">(</span><span class="dl">'</span><span class="s1">var</span><span class="dl">'</span><span class="p">),</span> <span class="nx">sub</span><span class="p">.</span><span class="nx">vars</span><span class="p">))</span> <span class="p">?</span> <span class="nx">makeSub</span><span class="p">(</span><span class="nx">sub</span><span class="p">.</span><span class="nx">vars</span><span class="p">,</span> <span class="nx">updatedTEs</span><span class="p">)</span> <span class="p">:</span>
               <span class="nx">makeSub</span><span class="p">(</span><span class="nx">cons</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">sub</span><span class="p">.</span><span class="nx">vars</span><span class="p">),</span> <span class="nx">cons</span><span class="p">(</span><span class="nx">te</span><span class="p">,</span> <span class="nx">updatedTEs</span><span class="p">));</span>
    <span class="p">});</span>
</code></pre></div></div>

<p>In addition, we explicitly “compile” extended substitutions which are the result of composing two substitutions into a flat representation,
using the value constructor <code class="language-plaintext highlighter-rouge">subCombine</code>.  Recall that substitution composition is defined as:</p>

<ul>
  <li>s’ is applied to the type-expressions of s, i.e., for every variable T’ for which s’(T’) is defined, occurrences of T’ in type expressions in s are replaced by s’(T’).</li>
  <li>A variable T’ in s’, for which s(T) is defined, is removed from the domain of s’, i.e., s’(T) is not defined on it anymore.</li>
  <li>The modified s’ is added to s.</li>
  <li>Identity bindings, i.e., s(T) = T, are removed.</li>
  <li>If for some variable, (s o s’)(T) includes T, the combination fails.</li>
</ul>

<p>This method is implemented literally in the <code class="language-plaintext highlighter-rouge">subCombine(sub1, sub2)</code> procedure - which has a structure similar to a reduce of the extendSub operation over all the pairs in sub2:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ============================================================</span>
<span class="c1">// Purpose: Returns the composition of substitutions s.t.:</span>
<span class="c1">//  applySub(result, te) === applySub(sub2, applySub(sub1, te))</span>
<span class="c1">// The composition fails if it would lead to a circular substitution.</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">combineSub</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sub1</span><span class="p">:</span> <span class="nx">Sub</span><span class="p">,</span> <span class="nx">sub2</span><span class="p">:</span> <span class="nx">Sub</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">Sub</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">isEmptySub</span><span class="p">(</span><span class="nx">sub1</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="nx">sub2</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">isEmptySub</span><span class="p">(</span><span class="nx">sub2</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="nx">sub1</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">combine</span><span class="p">(</span><span class="nx">sub1</span><span class="p">,</span> <span class="nx">sub2</span><span class="p">.</span><span class="nx">vars</span><span class="p">,</span> <span class="nx">sub2</span><span class="p">.</span><span class="nx">tes</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">combine</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sub</span><span class="p">:</span> <span class="nx">Sub</span><span class="p">,</span> <span class="nx">vars</span><span class="p">:</span> <span class="nx">TVar</span><span class="p">[],</span> <span class="nx">tes</span><span class="p">:</span> <span class="nx">TExp</span><span class="p">[]):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">Sub</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">isEmpty</span><span class="p">(</span><span class="nx">vars</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="nx">sub</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">extendSub</span><span class="p">(</span><span class="nx">sub</span><span class="p">,</span> <span class="nx">first</span><span class="p">(</span><span class="nx">vars</span><span class="p">),</span> <span class="nx">first</span><span class="p">(</span><span class="nx">tes</span><span class="p">)),</span> 
         <span class="p">(</span><span class="nx">extSub</span><span class="p">:</span> <span class="nx">Sub</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">combine</span><span class="p">(</span><span class="nx">extSub</span><span class="p">,</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">vars</span><span class="p">),</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">tes</span><span class="p">)));</span>
</code></pre></div></div>

<h3 id="type-equations-module">Type Equations Module</h3>

<p>The type equations module follows the definition of the algorithm:</p>

<ul>
  <li>Rename bound variables in e.</li>
  <li>Assign type variables to all sub-expressions.</li>
  <li>Construct type equations.</li>
  <li>Solve the equations.</li>
</ul>

<p>Renaming of all bound variables in <code class="language-plaintext highlighter-rouge">e</code> is performed in the same way as we introduced when discussing the Substitution model for Operational Semantics.
We do not repeat this code here, and instead make the assumption that in the following, all bound variables have distinct names
(the same variable name is never used twice in different scopes).</p>

<p>We implement the assignment of type variables to all sub-expressions by defining a data structure which we call the <strong>pool</strong>
which contains a list of pairs <code class="language-plaintext highlighter-rouge">(exp Tvar)</code> for every node in the expression AST.</p>

<p>The pool is a list of pairs (expression-AST-node, type variable) which exhaustively includes all the sub-expressions in the AST. 
It is built using the function <code class="language-plaintext highlighter-rouge">expToPool</code>.  As usual, this function is an AST traversal method.
Whenever a node in the AST is visited, we allocate a fresh Type Variable for it.</p>

<p>Pay attention to the way variable declarations and variable references are processed when constructing the pool.</p>

<ul>
  <li>The method <code class="language-plaintext highlighter-rouge">extendPool(exp, pool)</code> generates a fresh new type variable (one that was never used before) and adds the mapping from exp to that new type variable to the pool.</li>
  <li>When we enter a new scope in the expression (during its traversal), we need to keep track of the variable declarations - and map the variable name to the type of the variable declaration.  Recall that when we parse an <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="7" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mn>5</mn></math></mjx-assistive-mml></mjx-container> expression, we consider type annotations optional.  If they are provided, the VarDecl node stores the declared type expression in the <code class="language-plaintext highlighter-rouge">VarDecl.texp</code> field.
If they are not provided by the programmer, the parser generates a new fresh variable and associates it to <code class="language-plaintext highlighter-rouge">varDecl.texp</code>.</li>
</ul>

<p>When we continue the traversal of the AST, and we later meet a VarRef node which refers to this VarDecl node, we want to associate it to the existing VarDecl type declaration (whether it is provided by the programmer or allocated by the parser).</p>

<p>To achieve this mechanism, when we meet a var-decl node, we use the procedure <code class="language-plaintext highlighter-rouge">extendPoolVarDecl(varDecl, pool)</code> which
adds the pair <code class="language-plaintext highlighter-rouge">(varRef(varDecl.var) varDecl.texp))</code> to the pool.
When we later reach a VarRef in the scope of this VarDecl, we find that the pair <code class="language-plaintext highlighter-rouge">(VarRef tvar)</code> already exists in the pool, and we do not allocate any new fresh type variable for it.</p>

<p>This mechanism crucially depends on the fact that <code class="language-plaintext highlighter-rouge">expToPool</code> traverses the expression ADT top-down (traverse the VarDecl <em>before</em> the corresponding <code class="language-plaintext highlighter-rouge">VarRef</code> 
nodes are met) <strong>and</strong> the expression has been renamed before so that all <code class="language-plaintext highlighter-rouge">VarRefs</code> with a given name refer to the single <code class="language-plaintext highlighter-rouge">VarDecl</code> with the same name.</p>

<p><code class="language-plaintext highlighter-rouge">expToPool</code> uses the function <code class="language-plaintext highlighter-rouge">reducePool</code> to accumulate the pairs (AST-node TVar) into the pool without repetitions.
This function is a variant of the <code class="language-plaintext highlighter-rouge">reduce</code> family of higher-order functions.</p>

<h3 id="optionalt-and-maybe"><code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">maybe</code></h3>

<p>We use in these functions the <code class="language-plaintext highlighter-rouge">inPool</code> function which checks whether an expression is already present in the pool.
In case the expression is found, we return the associated <code class="language-plaintext highlighter-rouge">TExp</code>, else we need to return a value that indicates the expression was not found.
This is a typical situation where we have a search operator which can fail.  We adopt the standard <code class="language-plaintext highlighter-rouge">Optional</code> generic type
to represent this return type in a type-safe manner.
In the same way as <code class="language-plaintext highlighter-rouge">Result</code> represents a call which may fail, <code class="language-plaintext highlighter-rouge">Optional</code> represents a call which may either return a value or the legitimate case
of a missing value (which should not be considered an error). 
The two options are wrapped as <code class="language-plaintext highlighter-rouge">Some&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">None</code> (parallel to <code class="language-plaintext highlighter-rouge">Ok&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Failure</code> for <code class="language-plaintext highlighter-rouge">Result&lt;T&gt;</code>).
To manipulate <code class="language-plaintext highlighter-rouge">Optional</code> values, we use the <code class="language-plaintext highlighter-rouge">maybe</code> operator which passes the <code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code> two possible continuations:
a method receiving a <code class="language-plaintext highlighter-rouge">T</code> value in case the value was found, and one receiving no argument in case none was found.
<code class="language-plaintext highlighter-rouge">maybe</code> belongs to the family of <strong>fold</strong> operators in functional programming: it is used to reduce a data structure containing multiple values into a single one
(in the case of product-like types like arrays, <code class="language-plaintext highlighter-rouge">reduce</code> belongs to the fold family; in the case of sum-like types (unions) like Result or Option, 
a fold-operator provides one procedure for each case - as in the <code class="language-plaintext highlighter-rouge">maybe</code> operator).</p>

<p>We also implement a <code class="language-plaintext highlighter-rouge">bind</code> versions for <code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code> values with the same behavior as that we adopted for <code class="language-plaintext highlighter-rouge">Result&lt;T&gt;</code>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Purpose: construct a pool with one additional pair</span>
<span class="c1">//          [exp, fresh-tvar]</span>
<span class="c1">// @Pre: exp is not already in pool.</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">extendPool</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">,</span> <span class="nx">pool</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">):</span> <span class="nx">Pool</span> <span class="o">=&gt;</span>
    <span class="nx">cons</span><span class="p">({</span><span class="na">e</span><span class="p">:</span> <span class="nx">exp</span><span class="p">,</span> <span class="na">te</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">makeFreshTVar</span><span class="p">()},</span> <span class="nx">pool</span><span class="p">);</span>

<span class="c1">// Purpose: construct a pool with one additional pair</span>
<span class="c1">//          [VarRef(var), texp]</span>
<span class="c1">//          from a VarDecl(var, texp) declaration.</span>
<span class="c1">// @Pre: var is not already in pool - which means</span>
<span class="c1">// that all bound variables have been renamed with distinct names.</span>
<span class="kd">const</span> <span class="nx">extendPoolVarDecl</span> <span class="o">=</span> <span class="p">(</span><span class="nx">vd</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">VarDecl</span><span class="p">,</span> <span class="nx">pool</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">):</span> <span class="nx">Pool</span> <span class="o">=&gt;</span>
    <span class="nx">cons</span><span class="p">({</span><span class="na">e</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">makeVarRef</span><span class="p">(</span><span class="nx">vd</span><span class="p">.</span><span class="kd">var</span><span class="p">),</span> <span class="na">te</span><span class="p">:</span> <span class="nx">vd</span><span class="p">.</span><span class="nx">texp</span><span class="p">},</span> <span class="nx">pool</span><span class="p">);</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">inPool</span> <span class="o">=</span> <span class="p">(</span><span class="nx">pool</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">,</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">):</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">exp</span> <span class="o">=</span> <span class="nx">R</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">R</span><span class="p">.</span><span class="nx">propEq</span><span class="p">(</span><span class="dl">'</span><span class="s1">e</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">),</span> <span class="nx">pool</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">exp</span> <span class="p">?</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">makeSome</span><span class="p">(</span><span class="nx">R</span><span class="p">.</span><span class="nx">prop</span><span class="p">(</span><span class="dl">'</span><span class="s1">te</span><span class="dl">'</span><span class="p">)(</span><span class="nx">exp</span><span class="p">))</span> <span class="p">:</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">makeNone</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Map a function over a list of expressions to accumulate</span>
<span class="c1">// matching sub-expressions into a pool.</span>
<span class="c1">// fun should construct a new pool given a new expression from exp-list</span>
<span class="c1">// that has not yet been seen before.</span>
<span class="kd">const</span> <span class="nx">reducePool</span> <span class="o">=</span> <span class="p">(</span><span class="nx">fun</span><span class="p">:</span> <span class="p">(</span><span class="nx">e</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">,</span> <span class="nx">pool</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Pool</span><span class="p">,</span> <span class="nx">exps</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">[],</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">):</span> <span class="nx">Pool</span> <span class="o">=&gt;</span>
    <span class="nx">isEmpty</span><span class="p">(</span><span class="nx">exps</span><span class="p">)</span> <span class="p">?</span> <span class="nx">result</span> <span class="p">:</span>
    <span class="nx">Opt</span><span class="p">.</span><span class="nx">maybe</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">first</span><span class="p">(</span><span class="nx">exps</span><span class="p">)),</span>
              <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">reducePool</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">exps</span><span class="p">),</span> <span class="nx">result</span><span class="p">),</span>
              <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">reducePool</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">exps</span><span class="p">),</span> <span class="nx">fun</span><span class="p">(</span><span class="nx">first</span><span class="p">(</span><span class="nx">exps</span><span class="p">),</span> <span class="nx">result</span><span class="p">)));</span>

<span class="kd">const</span> <span class="nx">reducePoolVarDecls</span> <span class="o">=</span> <span class="p">(</span><span class="nx">fun</span><span class="p">:</span> <span class="p">(</span><span class="nx">e</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">VarDecl</span><span class="p">,</span> <span class="nx">pool</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Pool</span><span class="p">,</span> <span class="nx">vds</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">VarDecl</span><span class="p">[],</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">):</span> <span class="nx">Pool</span> <span class="o">=&gt;</span>
    <span class="nx">isEmpty</span><span class="p">(</span><span class="nx">vds</span><span class="p">)</span> <span class="p">?</span> <span class="nx">result</span> <span class="p">:</span>
    <span class="nx">Opt</span><span class="p">.</span><span class="nx">maybe</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">A</span><span class="p">.</span><span class="nx">makeVarRef</span><span class="p">(</span><span class="nx">first</span><span class="p">(</span><span class="nx">vds</span><span class="p">).</span><span class="kd">var</span><span class="p">)),</span>
              <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">reducePoolVarDecls</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">vds</span><span class="p">),</span> <span class="nx">result</span><span class="p">),</span>
              <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">reducePoolVarDecls</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">vds</span><span class="p">),</span> <span class="nx">fun</span><span class="p">(</span><span class="nx">first</span><span class="p">(</span><span class="nx">vds</span><span class="p">),</span> <span class="nx">result</span><span class="p">)));</span>

<span class="c1">// Purpose: Traverse the abstract syntax tree L5-exp</span>
<span class="c1">//          and collect all sub-expressions into a Pool of fresh type variables.</span>
<span class="c1">// Example:</span>
<span class="c1">// bind(bind(p('(+ x 1)'), parseL5Exp), e =&gt; makeOk(TE.expToPool(e))) =&gt;</span>
<span class="c1">// Ok([[AppExp(PrimOp(+), [VarRef(x), NumExp(1)]), TVar(16)],</span>
<span class="c1">//     [NumExp(1), TVar(15)],</span>
<span class="c1">//     [VarRef(x), TVar(14)],</span>
<span class="c1">//     [PrimOp(+), TVar(13)]])</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">expToPool</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">):</span> <span class="nx">Pool</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">findVars</span> <span class="o">=</span> <span class="p">(</span><span class="na">e</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">,</span> <span class="na">pool</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">):</span> <span class="nx">Pool</span> <span class="o">=&gt;</span>
        <span class="nx">A</span><span class="p">.</span><span class="nx">isAtomicExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">extendPool</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">pool</span><span class="p">)</span> <span class="p">:</span>
        <span class="nx">A</span><span class="p">.</span><span class="nx">isProcExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">extendPool</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">reducePool</span><span class="p">(</span><span class="nx">findVars</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span> 
                                    <span class="nx">reducePoolVarDecls</span><span class="p">(</span><span class="nx">extendPoolVarDecl</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">args</span><span class="p">,</span> <span class="nx">pool</span><span class="p">)))</span> <span class="p">:</span>
        <span class="nx">A</span><span class="p">.</span><span class="nx">isCompoundExp</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">?</span> <span class="nx">extendPool</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">reducePool</span><span class="p">(</span><span class="nx">findVars</span><span class="p">,</span> <span class="nx">A</span><span class="p">.</span><span class="nx">expComponents</span><span class="p">(</span><span class="nx">e</span><span class="p">),</span> <span class="nx">pool</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">makeEmptyPool</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">findVars</span><span class="p">(</span><span class="nx">exp</span><span class="p">,</span> <span class="nx">makeEmptyPool</span><span class="p">());</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The post-condition met at the end of the pool construction is that every node in the AST is mapped to a type variable - while preserving scoping relations
(different occurrences of the same varRef are all merged as a single pair mapping the varRef to its declared type - which can be a non-instantiated type variable).</p>

<h3 id="equations-generation">Equations Generation</h3>

<p>The next step of the algorithm consists of transforming the pool of {e:expression, te:TVar} pairs into a set of equations.
This part of the algorithm is the one that encapsulates the semantics of the type system used in the programming language.</p>

<p>The procedure <code class="language-plaintext highlighter-rouge">poolToequations</code> performs this mapping.  This procedure accumulates the transformation of all pairs
<code class="language-plaintext highlighter-rouge">{e:exp, te:Tvar}</code> in the pool to equations.  The equation ADT is a pair left-hand-side / right-hand-side of type expressions (that is, each equation is encoded as a pair <code class="language-plaintext highlighter-rouge">{left: TExp, right: TExp}</code>).</p>

<p>The heart of the typing algorithm is the operation <code class="language-plaintext highlighter-rouge">makeEquationsFromExp</code> which covers the typing rules of the programming language.  This implements the typing rules for procedure expressions, application expressions and atomic expressions.
For example, given a pair <code class="language-plaintext highlighter-rouge">( application-exp, TVar )</code>, the procedure derives a type equation which mandates that the type variable associated to the operator of the application must be made equal to the type expression <code class="language-plaintext highlighter-rouge">(T1 * ... * Tn -&gt; TVar)</code>
where <code class="language-plaintext highlighter-rouge">Ti</code> is the type variable associated to the ith argument of the application expression.</p>

<p>For the base cases of atomic types and primitive operators, we reuse the procedures <code class="language-plaintext highlighter-rouge">typeof-bool-exp</code>, <code class="language-plaintext highlighter-rouge">typeof-num-exp</code> and <code class="language-plaintext highlighter-rouge">typeof-prim-op</code> which we defined in the type checker.</p>

<p>Observe that there is no processing of <code class="language-plaintext highlighter-rouge">if-exp</code> - do you understand why?</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Signature: make-equation-from-exp(exp, pool)</span>
<span class="c1">// Purpose: Return a single equation</span>
<span class="c1">// @Pre: exp is a member of pool</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">makeEquationsFromExp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">,</span> <span class="nx">pool</span><span class="p">:</span> <span class="nx">Pool</span><span class="p">):</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">Equation</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="c1">// An application must respect the type of its operator</span>
    <span class="c1">// Type(Operator) = [T1 * .. * Tn -&gt; Te]</span>
    <span class="c1">// Type(Application) = Te</span>
    <span class="nx">A</span><span class="p">.</span><span class="nx">isAppExp</span><span class="p">(</span><span class="nx">exp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">exp</span><span class="p">.</span><span class="nx">rator</span><span class="p">),</span> <span class="p">(</span><span class="nx">rator</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span>
                        <span class="nx">Opt</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">Opt</span><span class="p">.</span><span class="nx">mapOptional</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">e</span><span class="p">),</span> <span class="nx">exp</span><span class="p">.</span><span class="nx">rands</span><span class="p">),</span> <span class="p">(</span><span class="nx">rands</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">[])</span> <span class="o">=&gt;</span>
                            <span class="nx">Opt</span><span class="p">.</span><span class="nx">mapv</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">exp</span><span class="p">),</span> <span class="p">(</span><span class="nx">e</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span> 
                                <span class="p">[</span><span class="nx">makeEquation</span><span class="p">(</span><span class="nx">rator</span><span class="p">,</span> <span class="nx">T</span><span class="p">.</span><span class="nx">makeProcTExp</span><span class="p">(</span><span class="nx">rands</span><span class="p">,</span> <span class="nx">e</span><span class="p">))])))</span> <span class="p">:</span>
    <span class="c1">// The type of procedure is (T1 * ... * Tn -&gt; Te)</span>
    <span class="c1">// where Te is the type of the last exp in the body of the proc.</span>
    <span class="c1">// and   Ti is the type of each of the parameters.</span>
    <span class="c1">// No need to traverse the other body expressions - they will be</span>
    <span class="c1">// traversed by the overall loop of pool-&gt;equations</span>
    <span class="nx">A</span><span class="p">.</span><span class="nx">isProcExp</span><span class="p">(</span><span class="nx">exp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">exp</span><span class="p">),</span> <span class="p">(</span><span class="nx">left</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span>
                            <span class="nx">Opt</span><span class="p">.</span><span class="nx">mapv</span><span class="p">(</span><span class="nx">Opt</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">safeLast</span><span class="p">(</span><span class="nx">exp</span><span class="p">.</span><span class="nx">body</span><span class="p">),</span> <span class="p">(</span><span class="nx">last</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">CExp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">last</span><span class="p">)),</span> <span class="p">(</span><span class="nx">ret</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span>
                                <span class="p">[</span><span class="nx">makeEquation</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">T</span><span class="p">.</span><span class="nx">makeProcTExp</span><span class="p">(</span><span class="nx">R</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">vd</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">vd</span><span class="p">.</span> <span class="nx">texp</span><span class="p">,</span> <span class="nx">exp</span><span class="p">.</span><span class="nx">args</span><span class="p">),</span> <span class="nx">ret</span><span class="p">))]))</span> <span class="p">:</span>
    <span class="c1">// The type of a number is Number</span>
    <span class="nx">A</span><span class="p">.</span><span class="nx">isNumExp</span><span class="p">(</span><span class="nx">exp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">mapv</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">exp</span><span class="p">),</span> <span class="p">(</span><span class="nx">left</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">makeEquation</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">T</span><span class="p">.</span><span class="nx">makeNumTExp</span><span class="p">())])</span> <span class="p">:</span>
    <span class="c1">// The type of a boolean is Boolean</span>
    <span class="nx">A</span><span class="p">.</span><span class="nx">isBoolExp</span><span class="p">(</span><span class="nx">exp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">mapv</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">exp</span><span class="p">),</span> <span class="p">(</span><span class="nx">left</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">makeEquation</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">T</span><span class="p">.</span><span class="nx">makeBoolTExp</span><span class="p">())])</span> <span class="p">:</span>
    <span class="c1">// The type of a string is String</span>
    <span class="nx">A</span><span class="p">.</span><span class="nx">isStrExp</span><span class="p">(</span><span class="nx">exp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">mapv</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">exp</span><span class="p">),</span> <span class="p">(</span><span class="nx">left</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">makeEquation</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">T</span><span class="p">.</span><span class="nx">makeStrTExp</span><span class="p">())])</span> <span class="p">:</span>
    <span class="c1">// The type of a primitive procedure is given by the primitive.</span>
    <span class="nx">A</span><span class="p">.</span><span class="nx">isPrimOp</span><span class="p">(</span><span class="nx">exp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">exp</span><span class="p">),</span> <span class="p">(</span><span class="nx">left</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span>
                            <span class="nx">Opt</span><span class="p">.</span><span class="nx">mapv</span><span class="p">(</span><span class="nx">Res</span><span class="p">.</span><span class="nx">resultToOptional</span><span class="p">(</span><span class="nx">TC</span><span class="p">.</span><span class="nx">typeofPrim</span><span class="p">(</span><span class="nx">exp</span><span class="p">)),</span> <span class="p">(</span><span class="nx">right</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span>
                                <span class="p">[</span><span class="nx">makeEquation</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)]))</span> <span class="p">:</span>
    <span class="c1">// Todo: define, let, letrec, set </span>
    <span class="nx">Opt</span><span class="p">.</span><span class="nx">makeNone</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="solving-the-type-equations-system">Solving the Type Equations System</h3>

<p>The last stage of the algorithm consists of solving the set of equations collected by the equations generator.
The procedure <code class="language-plaintext highlighter-rouge">solve(equations, substitution)</code> is a direct implementation of the solve algorithm presented in the 
last lecture.  It computes the unifier of all the equations - that is, it computes a type substitution which when it 
is applied to both sides of all the equations, makes the two sides identical.</p>

<p>This unifier substitution is computed incrementally, by processing each equation in turn.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Input</span><span class="p">:</span>  <span class="nx">A</span> <span class="kd">set</span> <span class="k">of</span> <span class="kd">type</span> <span class="nx">equations</span><span class="p">.</span>
<span class="nx">Output</span><span class="p">:</span> <span class="nx">A</span> <span class="kd">type</span> <span class="nx">substitution</span> <span class="k">of</span> <span class="nx">FAIL</span><span class="p">.</span>

<span class="nx">Initialization</span><span class="p">:</span>
  <span class="nx">substitution</span> <span class="p">:</span><span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
  <span class="nx">Order</span> <span class="nx">the</span> <span class="kd">set</span> <span class="k">of</span> <span class="nx">input</span> <span class="nx">equations</span> <span class="k">in</span> <span class="kr">any</span> <span class="nx">sequential</span> <span class="nx">order</span><span class="p">.</span>
  <span class="nx">equation</span> <span class="p">:</span><span class="o">=</span> <span class="nx">te1</span> <span class="o">=</span> <span class="nx">te2</span><span class="p">,</span> <span class="nx">the</span> <span class="nx">first</span> <span class="nx">equation</span><span class="p">.</span>

<span class="nx">Loop</span><span class="p">:</span>
  <span class="mi">1</span><span class="p">.</span> <span class="nx">Apply</span> <span class="nx">the</span> <span class="nx">current</span> <span class="nx">substitution</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">equation</span><span class="p">:</span> 
     <span class="nx">equation</span> <span class="p">:</span><span class="o">=</span> <span class="o">&lt;</span><span class="nx">te1</span> <span class="nx">o</span> <span class="nx">substitution</span> <span class="o">=</span> <span class="nx">te2</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="o">&gt;</span>

  <span class="mi">2</span><span class="p">.</span> <span class="nx">If</span> <span class="p">[</span><span class="nx">te1</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="nx">and</span> <span class="p">[</span><span class="nx">te2</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="nx">are</span> <span class="nx">atomic</span> <span class="nx">types</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">[</span><span class="nx">te1</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="nx">te2</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]:</span> 
            <span class="nx">substitution</span> <span class="p">:</span><span class="o">=</span> <span class="nx">FAIL</span>
        <span class="nx">otherwise</span><span class="p">:</span> 
            <span class="nx">Do</span> <span class="nx">nothing</span><span class="p">.</span>

  <span class="mi">3</span><span class="p">.</span> <span class="nx">Without</span> <span class="nx">loss</span> <span class="k">of</span> <span class="nx">generality</span><span class="p">:</span>
     <span class="nx">If</span> <span class="p">[</span><span class="nx">te1</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="o">=</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">i</span><span class="p">.</span><span class="nx">e</span><span class="p">.,</span> <span class="nx">a</span> <span class="kd">type</span> <span class="nx">variable</span><span class="p">,</span> <span class="nx">and</span> <span class="p">[</span><span class="nx">te1</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="nx">te2</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]:</span>
         <span class="nx">substitution</span> <span class="p">:</span><span class="o">=</span> <span class="nx">substitution</span> <span class="nx">o</span> <span class="p">{</span><span class="nx">T</span> <span class="o">=</span> <span class="p">[</span><span class="nx">te2</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]}.</span> 
         <span class="nx">That</span> <span class="k">is</span><span class="p">,</span> <span class="nx">apply</span> <span class="nx">the</span> <span class="nx">equation</span> <span class="nx">to</span> <span class="nx">substitution</span><span class="p">,</span> <span class="nx">and</span> <span class="nx">add</span> <span class="nx">the</span> <span class="nx">equation</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">substitution</span><span class="p">.</span> 
         <span class="nx">If</span> <span class="nx">the</span> <span class="nx">application</span> <span class="nx">fails</span> <span class="p">(</span><span class="nx">circular</span> <span class="nx">mapping</span><span class="p">),</span> <span class="nx">substitution</span> <span class="p">:</span><span class="o">=</span> <span class="nx">FAIL</span><span class="p">.</span>

  <span class="mi">4</span><span class="p">.</span> <span class="k">if</span> <span class="p">[</span><span class="nx">te1</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="nx">and</span> <span class="p">[</span><span class="nx">te2</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="nx">are</span> <span class="nx">composite</span> <span class="nx">types</span><span class="p">:</span>
         <span class="k">if</span> <span class="nx">they</span> <span class="nx">have</span> <span class="nx">the</span> <span class="nx">same</span> <span class="kd">type</span> <span class="kd">constructor</span><span class="p">:</span> 
             <span class="nx">Split</span> <span class="p">[</span><span class="nx">te1</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="nx">and</span> <span class="p">[</span><span class="nx">te2</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="nx">into</span> <span class="nx">component</span> <span class="kd">type</span> <span class="nx">expressions</span><span class="p">,</span> 
             <span class="nx">Create</span> <span class="nx">equations</span> <span class="k">for</span> <span class="nx">corresponding</span> <span class="nx">components</span><span class="p">,</span> <span class="nx">and</span> 
             <span class="nx">Add</span> <span class="nx">the</span> <span class="k">new</span> <span class="nx">equations</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">pool</span> <span class="k">of</span> <span class="nx">equations</span><span class="p">.</span>
         <span class="k">if</span> <span class="nx">they</span> <span class="nx">have</span> <span class="nx">different</span> <span class="kd">type</span> <span class="nx">constructors</span><span class="p">:</span> <span class="nx">substitution</span> <span class="p">:</span><span class="o">=</span> <span class="nx">FAIL</span>

  <span class="mi">5</span><span class="p">.</span> <span class="nx">Without</span> <span class="nx">loss</span> <span class="k">of</span> <span class="nx">generality</span><span class="p">:</span>
     <span class="k">if</span> <span class="p">[</span><span class="nx">te1</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="k">is</span> <span class="nx">an</span> <span class="nx">atomic</span> <span class="kd">type</span> <span class="nx">and</span> <span class="p">[</span><span class="nx">te2</span> <span class="nx">o</span> <span class="nx">substitution</span><span class="p">]</span> <span class="k">is</span> <span class="nx">a</span> <span class="nx">composite</span> <span class="kd">type</span><span class="p">:</span> 
         <span class="nx">substitution</span> <span class="p">:</span><span class="o">=</span> <span class="nx">FAIL</span>

  <span class="mi">6</span><span class="p">.</span> <span class="k">if</span> <span class="nx">there</span> <span class="k">is</span> <span class="nx">a</span> <span class="nx">next</span> <span class="nx">equation</span><span class="p">:</span> <span class="nx">equation</span> <span class="p">:</span><span class="o">=</span> <span class="nx">next</span><span class="p">(</span><span class="nx">equation</span><span class="p">)</span>

<span class="nx">until</span> <span class="nx">substitution</span> <span class="o">=</span> <span class="nx">FAIL</span> <span class="nx">or</span>
      <span class="nx">there</span> <span class="k">is</span> <span class="nx">no</span> <span class="nx">next</span> <span class="nx">equation</span><span class="p">.</span>

<span class="nx">Return</span><span class="p">:</span> <span class="nx">Substitution</span>
</code></pre></div></div>

<p>This algorithm is implemented in the following procedure:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">solveEquations</span> <span class="o">=</span> <span class="p">(</span><span class="nx">equations</span><span class="p">:</span> <span class="nx">Equation</span><span class="p">[]):</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">Result</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">.</span><span class="nx">Sub</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">solve</span><span class="p">(</span><span class="nx">equations</span><span class="p">,</span> <span class="nx">S</span><span class="p">.</span><span class="nx">makeEmptySub</span><span class="p">());</span>

<span class="c1">// Purpose: Solve the equations, starting from a given substitution.</span>
<span class="c1">//          Returns the resulting substitution, or error, if not solvable</span>
<span class="kd">const</span> <span class="nx">solve</span> <span class="o">=</span> <span class="p">(</span><span class="nx">equations</span><span class="p">:</span> <span class="nx">Equation</span><span class="p">[],</span> <span class="nx">sub</span><span class="p">:</span> <span class="nx">S</span><span class="p">.</span><span class="nx">Sub</span><span class="p">):</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">Result</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">.</span><span class="nx">Sub</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">solveVarEq</span> <span class="o">=</span> <span class="p">(</span><span class="na">tvar</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TVar</span><span class="p">,</span> <span class="na">texp</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">):</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">Result</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">.</span><span class="nx">Sub</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
        <span class="nx">Res</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">S</span><span class="p">.</span><span class="nx">extendSub</span><span class="p">(</span><span class="nx">sub</span><span class="p">,</span> <span class="nx">tvar</span><span class="p">,</span> <span class="nx">texp</span><span class="p">),</span> <span class="nx">sub2</span> <span class="o">=&gt;</span> <span class="nx">solve</span><span class="p">(</span><span class="nx">rest</span><span class="p">(</span><span class="nx">equations</span><span class="p">),</span> <span class="nx">sub2</span><span class="p">));</span>

    <span class="kd">const</span> <span class="nx">bothSidesAtomic</span> <span class="o">=</span> <span class="p">(</span><span class="na">eq</span><span class="p">:</span> <span class="nx">Equation</span><span class="p">):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span>
        <span class="nx">T</span><span class="p">.</span><span class="nx">isAtomicTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isAtomicTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">handleBothSidesAtomic</span> <span class="o">=</span> <span class="p">(</span><span class="na">eq</span><span class="p">:</span> <span class="nx">Equation</span><span class="p">):</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">Result</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">.</span><span class="nx">Sub</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
        <span class="nx">T</span><span class="p">.</span><span class="nx">isAtomicTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isAtomicTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">eqAtomicTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
        <span class="p">?</span> <span class="nx">solve</span><span class="p">(</span><span class="nx">rest</span><span class="p">(</span><span class="nx">equations</span><span class="p">),</span> <span class="nx">sub</span><span class="p">)</span>
        <span class="p">:</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">makeFailure</span><span class="p">(</span><span class="s2">`Equation with non-equal atomic type </span><span class="p">${</span><span class="nx">eq</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">isEmpty</span><span class="p">(</span><span class="nx">equations</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">makeOk</span><span class="p">(</span><span class="nx">sub</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">eq</span> <span class="o">=</span> <span class="nx">makeEquation</span><span class="p">(</span><span class="nx">S</span><span class="p">.</span><span class="nx">applySub</span><span class="p">(</span><span class="nx">sub</span><span class="p">,</span> <span class="nx">first</span><span class="p">(</span><span class="nx">equations</span><span class="p">).</span><span class="nx">left</span><span class="p">),</span>
                            <span class="nx">S</span><span class="p">.</span><span class="nx">applySub</span><span class="p">(</span><span class="nx">sub</span><span class="p">,</span> <span class="nx">first</span><span class="p">(</span><span class="nx">equations</span><span class="p">).</span><span class="nx">right</span><span class="p">));</span>

    <span class="k">return</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">?</span> <span class="nx">solveVarEq</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">:</span>
           <span class="nx">T</span><span class="p">.</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">?</span> <span class="nx">solveVarEq</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">:</span>
           <span class="nx">bothSidesAtomic</span><span class="p">(</span><span class="nx">eq</span><span class="p">)</span> <span class="p">?</span> <span class="nx">handleBothSidesAtomic</span><span class="p">(</span><span class="nx">eq</span><span class="p">)</span> <span class="p">:</span>
           <span class="nx">T</span><span class="p">.</span><span class="nx">isCompoundTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isCompoundTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">canUnify</span><span class="p">(</span><span class="nx">eq</span><span class="p">)</span> <span class="p">?</span>
                <span class="nx">solve</span><span class="p">(</span><span class="nx">R</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">rest</span><span class="p">(</span><span class="nx">equations</span><span class="p">),</span> <span class="nx">splitEquation</span><span class="p">(</span><span class="nx">eq</span><span class="p">)),</span> <span class="nx">sub</span><span class="p">)</span> <span class="p">:</span>
           <span class="nx">Res</span><span class="p">.</span><span class="nx">makeFailure</span><span class="p">(</span><span class="s2">`Equation contains incompatible types </span><span class="p">${</span><span class="nx">eq</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The logic of the unification is implemented in the procedures <code class="language-plaintext highlighter-rouge">canUnify</code> and <code class="language-plaintext highlighter-rouge">splitEquation</code>.
These procedures transform an equation of the form:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nx">T1</span> <span class="o">*</span> <span class="p">...</span> <span class="o">*</span> <span class="nx">Tn</span> <span class="o">-&gt;</span> <span class="nx">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">U1</span> <span class="o">*</span> <span class="p">...</span> <span class="o">*</span> <span class="nx">Un</span> <span class="o">-&gt;</span> <span class="nx">U</span><span class="p">]</span>
</code></pre></div></div>
<p>into <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="8" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>+</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container> equations of the form:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nx">T1</span> <span class="o">=</span> <span class="nx">U1</span><span class="p">]</span>
<span class="p">...</span>
<span class="p">[</span><span class="nx">Tn</span> <span class="o">=</span> <span class="nx">Un</span><span class="p">]</span>
<span class="p">[</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">U</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Signature: canUnify(equation)</span>
<span class="c1">// Purpose: Compare the structure of the type expressions of the equation</span>
<span class="kd">const</span> <span class="nx">canUnify</span> <span class="o">=</span> <span class="p">(</span><span class="nx">eq</span><span class="p">:</span> <span class="nx">Equation</span><span class="p">):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span>
    <span class="nx">T</span><span class="p">.</span><span class="nx">isProcTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isProcTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">paramTEs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span><span class="nx">paramTEs</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>

<span class="c1">// Signature: splitEquation(equation)</span>
<span class="c1">// Purpose: For an equation with unifyable type expressions,</span>
<span class="c1">//          create equations for corresponding components.</span>
<span class="c1">// Type: [Equation -&gt; List(Equation)]</span>
<span class="c1">// Example: splitEquation(</span>
<span class="c1">//            makeEquation(parseTExp('(T1 -&gt; T2)'),</span>
<span class="c1">//                         parseTExp('(T3 -&gt; (T4 -&gt; T4))')) =&gt;</span>
<span class="c1">//            [ {left:T2, right: (T4 -&gt; T4)},</span>
<span class="c1">//              {left:T3, right: T1)} ]</span>
<span class="c1">// @Pre: isCompoundExp(eq.left) &amp;&amp; isCompoundExp(eq.right) &amp;&amp; canUnify(eq)</span>
<span class="kd">const</span> <span class="nx">splitEquation</span> <span class="o">=</span> <span class="p">(</span><span class="nx">eq</span><span class="p">:</span> <span class="nx">Equation</span><span class="p">):</span> <span class="nx">Equation</span><span class="p">[]</span> <span class="o">=&gt;</span>
    <span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">isProcTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isProcTExp</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">))</span> <span class="p">?</span>
        <span class="nx">R</span><span class="p">.</span><span class="nx">zipWith</span><span class="p">(</span><span class="nx">makeEquation</span><span class="p">,</span>
                  <span class="nx">R</span><span class="p">.</span><span class="nx">prepend</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">returnTE</span><span class="p">,</span> <span class="nx">eq</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">paramTEs</span><span class="p">),</span>
                  <span class="nx">R</span><span class="p">.</span><span class="nx">prepend</span><span class="p">(</span><span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span><span class="nx">returnTE</span><span class="p">,</span> <span class="nx">eq</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span><span class="nx">paramTEs</span><span class="p">))</span> <span class="p">:</span>
    <span class="p">[];</span>
</code></pre></div></div>

<h4 id="solve-termination-argument">Solve Termination Argument</h4>

<p>How do we know that the <code class="language-plaintext highlighter-rouge">solve</code> algorithm terminates given a list of type expression equations?</p>

<p>The main loop of the algorithm has for state the current list of equations and the current substitution.</p>

<p>Let us consider the effect of one iteration through the main loop:</p>
<ul>
  <li>Either we consume one equation from the current equations set and produce a more complex substitution (this happens when one of the sides of the first equation is an atomic type expression or a type variable).</li>
  <li>Or we replace one equation with multiple equations: this happens when both sides of the equation are composite type expressions with compatible structure.  In this case, we replace one equation with AST trees of depth <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="9" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi></math></mjx-assistive-mml></mjx-container> with <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="10" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> equations of depth <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="11" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>−</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container> where <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="12" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> is the number of children of the ASTs.  In our case, composite ASTs in the type language are <code class="language-plaintext highlighter-rouge">procTExp</code> nodes which represent the type of procedures - with <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="13" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> children elements for the arguments of the procedure and one element for the return type.</li>
  <li>Or we fail the solve process when we detect an incompatible equation.</li>
</ul>

<p>The argument for completion is based on the characterization of the <em>size</em> of the input equation set as a pair <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="14" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>D</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> where <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="15" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi></math></mjx-assistive-mml></mjx-container> is  the maximum height of the ASTs that appear in any equation in the equation set and <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="16" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></mjx-assistive-mml></mjx-container> is the number of equations in the set.</p>

<p>Each iteration in the loop changes the size to either <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="17" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>D</mi><mo>,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> or <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="18" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>D</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>N</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>.  When <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="19" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>=</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container>, the transition is necessarily to <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="20" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> because the only case where we add equations is for composite ASTs.  Hence all transitions lead to the completion state of <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="21" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="2"><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>.</p>

<h3 id="putting-all-steps-together-infertype">Putting all Steps Together: <code class="language-plaintext highlighter-rouge">inferType</code></h3>

<p>Putting all the steps of the algorithm together, we define the procedure <code class="language-plaintext highlighter-rouge">infer</code> and <code class="language-plaintext highlighter-rouge">verifyType</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ========================================================</span>
<span class="c1">// Purpose: Infer the type of an expression using the equations method</span>
<span class="c1">// Example: unparseTExp(inferType(parse('(lambda (f x) (f (f x)))')))</span>
<span class="c1">//          ==&gt; '((T_1 -&gt; T_1) * T_1 -&gt; T_1)'</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">inferType</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">):</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">pool</span> <span class="o">=</span> <span class="nx">expToPool</span><span class="p">(</span><span class="nx">exp</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">equations</span> <span class="o">=</span> <span class="nx">poolToEquations</span><span class="p">(</span><span class="nx">pool</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">sub</span> <span class="o">=</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">equations</span><span class="p">,</span> <span class="p">(</span><span class="na">eqns</span><span class="p">:</span> <span class="nx">Equation</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">resultToOptional</span><span class="p">(</span><span class="nx">solveEquations</span><span class="p">(</span><span class="nx">eqns</span><span class="p">)))</span>
    <span class="kd">const</span> <span class="nx">texp</span> <span class="o">=</span> <span class="nx">inPool</span><span class="p">(</span><span class="nx">pool</span><span class="p">,</span> <span class="nx">exp</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">sub</span><span class="p">,</span> <span class="p">(</span><span class="na">sub</span><span class="p">:</span> <span class="nx">S</span><span class="p">.</span><span class="nx">Sub</span><span class="p">)</span> <span class="o">=&gt;</span> 
             <span class="nx">Opt</span><span class="p">.</span><span class="nx">mapv</span><span class="p">(</span><span class="nx">texp</span><span class="p">,</span> <span class="p">(</span><span class="na">texp</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span> 
               <span class="nx">T</span><span class="p">.</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">texp</span><span class="p">)</span> <span class="p">?</span> <span class="nx">S</span><span class="p">.</span><span class="nx">subGet</span><span class="p">(</span><span class="nx">sub</span><span class="p">,</span> <span class="nx">texp</span><span class="p">)</span> <span class="p">:</span> 
               <span class="nx">texp</span><span class="p">));</span>
<span class="p">};</span>

<span class="c1">// Type: [Concrete-Exp -&gt; Concrete-TExp]</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">infer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">Result</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">Res</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">parseL5Exp</span><span class="p">(</span><span class="nx">exp</span><span class="p">),</span>
             <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Opt</span><span class="p">.</span><span class="nx">maybe</span><span class="p">(</span><span class="nx">inferType</span><span class="p">(</span><span class="nx">exp</span><span class="p">),</span>
                                       <span class="p">(</span><span class="nx">te</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te</span><span class="p">),</span>
                                       <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Res</span><span class="p">.</span><span class="nx">makeFailure</span><span class="p">(</span><span class="dl">"</span><span class="s2">Infer type failed</span><span class="dl">"</span><span class="p">)));</span>
</code></pre></div></div>

<p>This is invoked as follows:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nx">infer</span><span class="p">(</span><span class="dl">'</span><span class="s1">(lambda (f g) (lambda (n) (f (g n))))</span><span class="dl">'</span><span class="p">)</span>
<span class="p">{</span><span class="nl">tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ok</span><span class="dl">'</span><span class="p">,</span> <span class="p">((</span><span class="nx">T459051</span> <span class="o">-&gt;</span> <span class="nx">T459052</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">T459049</span> <span class="o">-&gt;</span> <span class="nx">T459051</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nx">T459049</span> <span class="o">-&gt;</span> <span class="nx">T459052</span><span class="p">))</span>
</code></pre></div></div>

<p>Observe the usage of freshly generated type variable names which are different each time we invoke the procedure.
This makes it difficult to test the procedure.</p>

<p>To resolve this difficulty, we introduce the procedure <code class="language-plaintext highlighter-rouge">equivalentTEs?</code> in TExp.ts which verifies that two type expressions are equivalent up to type variable renaming.  This allows us to write tests in a deterministic manner (see <a href="https://github.com/bguppl/interpreters/blob/master/test/L5/test-helpers.ts">test-helpers.ts</a>):</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">verifyTeOfExprWithEquations</span> <span class="o">=</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">texp</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">e</span> <span class="o">=</span> <span class="nx">bindResult</span><span class="p">(</span><span class="nx">p</span><span class="p">(</span><span class="nx">exp</span><span class="p">),</span> <span class="nx">parseL5Exp</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">expectedType</span> <span class="o">=</span> <span class="nx">parseTE</span><span class="p">(</span><span class="nx">texp</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">computedType</span> <span class="o">=</span> <span class="nx">bindResult</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="p">(</span><span class="na">exp</span><span class="p">:</span> <span class="nx">Exp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">optionalToResult</span><span class="p">(</span><span class="nx">inferType</span><span class="p">(</span><span class="nx">exp</span><span class="p">),</span> <span class="dl">"</span><span class="s2">Could not infer type</span><span class="dl">"</span><span class="p">));</span>
    <span class="k">return</span> <span class="nx">bindResult</span><span class="p">(</span><span class="nx">computedType</span><span class="p">,</span> <span class="p">(</span><span class="na">ct</span><span class="p">:</span> <span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span>
                <span class="nx">mapv</span><span class="p">(</span><span class="nx">expectedType</span><span class="p">,</span> <span class="p">(</span><span class="na">et</span><span class="p">:</span> <span class="nx">TExp</span><span class="p">)</span> <span class="o">=&gt;</span> 
                    <span class="nx">equivalentTEs</span><span class="p">(</span><span class="nx">ct</span><span class="p">,</span> <span class="nx">et</span><span class="p">)));</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This can be invoked as follows:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">expect</span><span class="p">(</span><span class="nx">verifyTeOfExprWithEquations</span><span class="p">(</span><span class="dl">"</span><span class="s2">(lambda (x y) x)</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">(T1 * T2 -&gt; T1)</span><span class="dl">"</span><span class="p">)).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
</code></pre></div></div>

<h2 id="type-inference-with-direct-unification">Type Inference with Direct Unification</h2>

<p>The implementation described above based on type equations follows literally the type equations algorithm.
It explicitly manipulates substitution data structures and type equations.  In addition, it constructs a map
of expression to type variables to ensure the exhaustive traversal of the program to be type-checked.</p>

<p>We present here an optimized version of this algorithm which relies on a slightly modified representation of the
type variable data structure.  Using this new data structure for type variables, we implement exactly the same
algorithm but avoid creating explicit data structures for the pool, the equations and the substitutions.
This leads to a more memory-efficient implementation, which also turns out to be more time efficient, as less
traversals of the data structures are required, and operations performed eargerly in the type equations method
are turned into lazy operations.</p>

<p>The complete code is available in <a href="https://github.com/bguppl/interpreters/blob/master/src/L5/L5-typeinference.ts">L5-typeinference.ts</a>.</p>

<p>Tests are in <a href="https://github.com/bguppl/interpreters/blob/master/test/L5/L5-typeinference.test.ts">L5-typeinference.test.ts</a>.</p>

<h3 id="type-variable-with-one-way-assignment">Type Variable with One-way Assignment</h3>

<p>The extension to the TVar data type we introduce is implemented as follows:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// TVar: Type Variable with support for dereferencing (TVar -&gt; TVar)</span>
<span class="k">export</span> <span class="kd">type</span> <span class="nx">TVar</span> <span class="o">=</span> <span class="p">{</span> <span class="na">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TVar</span><span class="dl">"</span><span class="p">;</span> <span class="nl">var</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span> <span class="nl">contents</span><span class="p">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="kc">undefined</span> <span class="o">|</span> <span class="nx">TExp</span><span class="o">&gt;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">isEmptyTVar</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">x</span> <span class="k">is</span> <span class="nx">TVar</span> <span class="o">=&gt;</span>
    <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">TVar</span><span class="dl">"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">unbox</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">contents</span><span class="p">)</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">makeTVar</span> <span class="o">=</span> <span class="p">(</span><span class="nx">v</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">TVar</span> <span class="o">=&gt;</span>
    <span class="p">({</span><span class="na">tag</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TVar</span><span class="dl">"</span><span class="p">,</span> <span class="na">var</span><span class="p">:</span> <span class="nx">v</span><span class="p">,</span> <span class="na">contents</span><span class="p">:</span> <span class="nx">makeBox</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)});</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">isTVar</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">x</span> <span class="k">is</span> <span class="nx">TVar</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">TVar</span><span class="dl">"</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">eqTVar</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tv1</span><span class="p">:</span> <span class="nx">TVar</span><span class="p">,</span> <span class="nx">tv2</span><span class="p">:</span> <span class="nx">TVar</span><span class="p">):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span> <span class="nx">tv1</span><span class="p">.</span><span class="kd">var</span> <span class="o">===</span> <span class="nx">tv2</span><span class="p">.</span><span class="kd">var</span><span class="p">;</span>
</code></pre></div></div>

<p>In addition to the name of the type variable, we associate a boxed value, initialized to <code class="language-plaintext highlighter-rouge">undefined</code>.
We use this new field in the TVar datatype to associate the TVar to another type expression,
when we derive a constraint that the variable must be bound to another type expression as part
of the type inference process.</p>

<p>We extend the TVar data type with the following methods:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">tvarContents</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tv</span><span class="p">:</span> <span class="nx">TVar</span><span class="p">):</span> <span class="kc">undefined</span> <span class="o">|</span> <span class="nx">TExp</span> <span class="o">=&gt;</span> <span class="nx">unbox</span><span class="p">(</span><span class="nx">tv</span><span class="p">.</span><span class="nx">contents</span><span class="p">);</span>
<span class="c1">// @Pre: tv is empty (one-way assignment)</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">tvarSetContents</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tv</span><span class="p">:</span> <span class="nx">TVar</span><span class="p">,</span> <span class="nx">val</span><span class="p">:</span> <span class="nx">TExp</span><span class="p">):</span> <span class="k">void</span> <span class="o">=&gt;</span>
    <span class="nx">setBox</span><span class="p">(</span><span class="nx">tv</span><span class="p">.</span><span class="nx">contents</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">tvarIsNonEmpty</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tv</span><span class="p">:</span> <span class="nx">TVar</span><span class="p">):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span> <span class="nx">tvarContents</span><span class="p">(</span><span class="nx">tv</span><span class="p">)</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
</code></pre></div></div>

<p>The assignment managed by TVar is <strong>one-way</strong> - we can only assign a value to an empty type variable.</p>

<p>In many occurrences, we will bind a TVar to another TVar.  When this is the case,
we are interested in accessing the type expression to which the referenced TVar refers.
That is, we create a graph of TVar references to other TVars which eventually lead to non-TVar expressions.
We want to follow the path of references from any TVar to a non-TVar value (which may be empty).</p>

<p>The method <code class="language-plaintext highlighter-rouge">VarDeref</code> performs this graph traversal:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">tvarDeref</span> <span class="o">=</span> <span class="p">(</span><span class="nx">te</span><span class="p">:</span> <span class="nx">TExp</span><span class="p">):</span> <span class="nx">TExp</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nx">isTVar</span><span class="p">(</span><span class="nx">te</span><span class="p">))</span> <span class="k">return</span> <span class="nx">te</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">contents</span> <span class="o">=</span> <span class="nx">tvarContents</span><span class="p">(</span><span class="nx">te</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">contents</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">te</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">contents</span><span class="p">))</span>
        <span class="k">return</span> <span class="nx">tvarDeref</span><span class="p">(</span><span class="nx">contents</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="nx">contents</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="unification-based-checktvarequaltype">Unification-based CheckTvarEqualType</h3>

<p>Using the one-way assignment TVar data structure, we return to the procedure <code class="language-plaintext highlighter-rouge">checkEqualType</code> which 
we defined in the Type Checker implementation.  The original implementation applied the <strong>invariance check</strong> and 
verified that two type expressions are identical (using the <code class="language-plaintext highlighter-rouge">deepEqual</code> predicate).<br>
When they were, the type checker proceeded - otherwise the type checking failed.</p>

<p>In the case of the type inference, we replace this type equal test with a different procedure, which
instead of testing that two types are equal, attempts to <strong>make them equal</strong> when they contain
type variables.  The way two type expressions are made equal is by <strong>unifying them</strong> - that is,
finding a substitution which when applied to both sides makes them equal.</p>

<p>But instead of representing the substitution as an explicit data structure (the <code class="language-plaintext highlighter-rouge">sub</code> type we defined in 
<a href="https://github.com/bguppl/interpreters/blob/master/src/L5/L5-substitution-adt.ts">L5-substitution-adt.ts</a>, we encode the substitution bindings <strong>within the TVar</strong> data structure.  When <code class="language-plaintext highlighter-rouge">Tvar1</code> is bound to a type expression <code class="language-plaintext highlighter-rouge">s(TVar1)</code>, we 
invoke <code class="language-plaintext highlighter-rouge">tvarSetContents(tvar1, te)</code>.</p>

<p>The following procedure effectively computes the MGU (most general unifier) in-place given two expressions te1 and te2 which may contain type variables:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Purpose: Make type expressions equivalent by deriving a unifier</span>
<span class="c1">// Return an error if the types are not unifiable.</span>
<span class="c1">// Exp is only passed for documentation purposes.</span>
<span class="c1">// te1 can be undefined when it is retrieved from a type variable which is not yet bound.</span>
<span class="kd">const</span> <span class="nx">checkEqualType</span> <span class="o">=</span> <span class="p">(</span><span class="nx">te1</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">te2</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">,</span> <span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">te1</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="p">?</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te2</span><span class="p">),</span> <span class="p">(</span><span class="nx">texp</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">makeFailure</span><span class="p">(</span><span class="s2">`Incompatible types: undefined - </span><span class="p">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">texp</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span><span class="s2">`</span><span class="p">))</span> <span class="p">:</span>
    <span class="nx">T</span><span class="p">.</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">te1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">te2</span><span class="p">)</span> <span class="p">?</span> <span class="p">((</span><span class="nx">T</span><span class="p">.</span><span class="nx">eqTVar</span><span class="p">(</span><span class="nx">te1</span><span class="p">,</span> <span class="nx">te2</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">:</span> <span class="nx">checkTVarEqualTypes</span><span class="p">(</span><span class="nx">te1</span><span class="p">,</span> <span class="nx">te2</span><span class="p">,</span> <span class="nx">exp</span><span class="p">)))</span> <span class="p">:</span>
    <span class="nx">T</span><span class="p">.</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">te1</span><span class="p">)</span> <span class="p">?</span> <span class="nx">checkTVarEqualTypes</span><span class="p">(</span><span class="nx">te1</span><span class="p">,</span> <span class="nx">te2</span><span class="p">,</span> <span class="nx">exp</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">T</span><span class="p">.</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">te2</span><span class="p">)</span> <span class="p">?</span> <span class="nx">checkTVarEqualTypes</span><span class="p">(</span><span class="nx">te2</span><span class="p">,</span> <span class="nx">te1</span><span class="p">,</span> <span class="nx">exp</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">T</span><span class="p">.</span><span class="nx">isAtomicTExp</span><span class="p">(</span><span class="nx">te1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isAtomicTExp</span><span class="p">(</span><span class="nx">te2</span><span class="p">)</span> <span class="p">?</span>
        <span class="nx">T</span><span class="p">.</span><span class="nx">eqAtomicTExp</span><span class="p">(</span><span class="nx">te1</span><span class="p">,</span> <span class="nx">te2</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">:</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te1</span><span class="p">),</span> <span class="p">(</span><span class="nx">te1</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span>
                                                    <span class="nx">bind</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te2</span><span class="p">),</span> <span class="p">(</span><span class="nx">te2</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span>
                                                        <span class="nx">makeFailure</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">`Incompatible atomic types </span><span class="p">${</span><span class="nx">te1</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">te2</span><span class="p">}</span><span class="s2">`</span><span class="p">)))</span> <span class="p">:</span>
    <span class="nx">T</span><span class="p">.</span><span class="nx">isProcTExp</span><span class="p">(</span><span class="nx">te1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">T</span><span class="p">.</span><span class="nx">isProcTExp</span><span class="p">(</span><span class="nx">te2</span><span class="p">)</span> <span class="p">?</span> <span class="nx">checkProcEqualTypes</span><span class="p">(</span><span class="nx">te1</span><span class="p">,</span> <span class="nx">te2</span><span class="p">,</span> <span class="nx">exp</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te1</span><span class="p">),</span> <span class="p">(</span><span class="nx">te1</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">bind</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te2</span><span class="p">),</span> <span class="p">(</span><span class="nx">te2</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span>
            <span class="nx">makeFailure</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">`Incompatible types structure: </span><span class="p">${</span><span class="nx">te1</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">te2</span><span class="p">}</span><span class="s2">`</span><span class="p">)));</span>

<span class="c1">// Purpose: make two lists of equal length of type expressions equal</span>
<span class="c1">// Return an error if one of the pair of TExps are not compatible - true otherwise.</span>
<span class="c1">// Exp is only passed for documentation purposes.</span>
<span class="kd">const</span> <span class="nx">checkEqualTypes</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tes1</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">[],</span> <span class="nx">tes2</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">[],</span> <span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">checks</span> <span class="o">=</span> <span class="nx">zipWithResult</span><span class="p">((</span><span class="nx">te1</span><span class="p">,</span> <span class="nx">te2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">checkEqualType</span><span class="p">(</span><span class="nx">te1</span><span class="p">,</span> <span class="nx">te2</span><span class="p">,</span> <span class="nx">exp</span><span class="p">),</span> <span class="nx">tes1</span><span class="p">,</span> <span class="nx">tes2</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">checks</span><span class="p">,</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">checkProcEqualTypes</span> <span class="o">=</span> <span class="p">(</span><span class="nx">te1</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">ProcTExp</span><span class="p">,</span> <span class="nx">te2</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">ProcTExp</span><span class="p">,</span> <span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">te1</span><span class="p">.</span><span class="nx">paramTEs</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">te2</span><span class="p">.</span><span class="nx">paramTEs</span><span class="p">.</span><span class="nx">length</span> <span class="p">?</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te1</span><span class="p">),</span> <span class="p">(</span><span class="nx">te1</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span>
                                                    <span class="nx">bind</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">unparseTExp</span><span class="p">(</span><span class="nx">te2</span><span class="p">),</span> <span class="p">(</span><span class="nx">te2</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span>
                                                        <span class="nx">makeFailure</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">`Wrong number of args </span><span class="p">${</span><span class="nx">te1</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">te2</span><span class="p">}</span><span class="s2">`</span><span class="p">)))</span> <span class="p">:</span>
    <span class="nx">checkEqualTypes</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">procTExpComponents</span><span class="p">(</span><span class="nx">te1</span><span class="p">),</span> <span class="nx">T</span><span class="p">.</span><span class="nx">procTExpComponents</span><span class="p">(</span><span class="nx">te2</span><span class="p">),</span> <span class="nx">exp</span><span class="p">);</span>
</code></pre></div></div>

<p>In exactly the same manner as we had to deal with the <strong>occur-check</strong> case in the substitution data type,
we must also avoid creating circular references in the graph of TVar references.
This is enforced in the <code class="language-plaintext highlighter-rouge">checkTVarEqualTypes</code> procedure which binds a TVar to a value - and makes sure
the reference type expression does not include a reference to TVar:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Purpose: check that a type variable matches a type expression</span>
<span class="c1">// Updates the var is needed to refer to te.</span>
<span class="c1">// Exp is only passed for documentation purposes.</span>
<span class="kd">const</span> <span class="nx">checkTVarEqualTypes</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tvar</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TVar</span><span class="p">,</span> <span class="nx">te</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">,</span> <span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
    <span class="nx">T</span><span class="p">.</span><span class="nx">tvarIsNonEmpty</span><span class="p">(</span><span class="nx">tvar</span><span class="p">)</span> <span class="p">?</span> <span class="nx">checkEqualType</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">tvarContents</span><span class="p">(</span><span class="nx">tvar</span><span class="p">),</span> <span class="nx">te</span><span class="p">,</span> <span class="nx">exp</span><span class="p">)</span> <span class="p">:</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">checkNoOccurrence</span><span class="p">(</span><span class="nx">tvar</span><span class="p">,</span> <span class="nx">te</span><span class="p">,</span> <span class="nx">exp</span><span class="p">),</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">T</span><span class="p">.</span><span class="nx">tvarSetContents</span><span class="p">(</span><span class="nx">tvar</span><span class="p">,</span> <span class="nx">te</span><span class="p">);</span> <span class="k">return</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="p">});</span>


<span class="c1">// Purpose: when attempting to bind tvar to te - check whether tvar occurs in te.</span>
<span class="c1">// Throws error if a circular reference is found.</span>
<span class="c1">// Exp is only passed for documentation purposes.</span>
<span class="c1">// Pre-conditions: Tvar is not bound</span>
<span class="kd">const</span> <span class="nx">checkNoOccurrence</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tvar</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TVar</span><span class="p">,</span> <span class="nx">te</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">,</span> <span class="nx">exp</span><span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Exp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">checkList</span> <span class="o">=</span> <span class="p">(</span><span class="na">tes</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">[]):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
        <span class="nx">bind</span><span class="p">(</span><span class="nx">mapResult</span><span class="p">(</span><span class="nx">loop</span><span class="p">,</span> <span class="nx">tes</span><span class="p">),</span> <span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>

    <span class="kd">const</span> <span class="nx">loop</span> <span class="o">=</span> <span class="p">(</span><span class="na">te1</span><span class="p">:</span> <span class="nx">T</span><span class="p">.</span><span class="nx">TExp</span><span class="p">):</span> <span class="nx">Result</span><span class="o">&lt;</span><span class="kc">true</span><span class="o">&gt;</span> <span class="o">=&gt;</span>
        <span class="nx">T</span><span class="p">.</span><span class="nx">isAtomicTExp</span><span class="p">(</span><span class="nx">te1</span><span class="p">)</span> <span class="p">?</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">:</span>
        <span class="nx">T</span><span class="p">.</span><span class="nx">isProcTExp</span><span class="p">(</span><span class="nx">te1</span><span class="p">)</span> <span class="p">?</span> <span class="nx">checkList</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">procTExpComponents</span><span class="p">(</span><span class="nx">te1</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">T</span><span class="p">.</span><span class="nx">isTVar</span><span class="p">(</span><span class="nx">te1</span><span class="p">)</span> <span class="p">?</span> <span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">eqTVar</span><span class="p">(</span><span class="nx">te1</span><span class="p">,</span> <span class="nx">tvar</span><span class="p">)</span> <span class="p">?</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">unparse</span><span class="p">(</span><span class="nx">exp</span><span class="p">),</span> <span class="p">(</span><span class="nx">exp</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">makeFailure</span><span class="p">(</span><span class="s2">`Occur check error - </span><span class="p">${</span><span class="nx">te1</span><span class="p">.</span><span class="kd">var</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">tvar</span><span class="p">.</span><span class="kd">var</span><span class="p">}</span><span class="s2"> in </span><span class="p">${</span><span class="nx">exp</span><span class="p">}</span><span class="s2">`</span><span class="p">))</span> <span class="p">:</span> <span class="nx">makeOk</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span> <span class="p">:</span>
        <span class="nx">bind</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">unparse</span><span class="p">(</span><span class="nx">exp</span><span class="p">),</span> <span class="p">(</span><span class="na">exp</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">makeFailure</span><span class="p">(</span><span class="s2">`Bad type expression - </span><span class="p">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">te1</span><span class="p">)}</span><span class="s2"> in </span><span class="p">${</span><span class="nx">exp</span><span class="p">}</span><span class="s2">`</span><span class="p">));</span>

    <span class="k">return</span> <span class="nx">loop</span><span class="p">(</span><span class="nx">te</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="type-inference-algorithm">Type Inference Algorithm</h3>

<p>Surprisingly, the type inference algorithm is <strong>exactly the same code</strong> as the Type Checker - except for the transformation of the procedure <code class="language-plaintext highlighter-rouge">checkEqualType</code> from a test of equality to the unification building version presented above.</p>

<p>The program that we obtain is in fact an implementation of the <strong>type equation</strong> algorithm - with the following transformations:</p>
<ul>
  <li>There is no explicit pool representation - instead, we pre-allocate type variables in all possible VarDecl and procedure return positions as part of the expression parsing (in <code class="language-plaintext highlighter-rouge">parse</code>).</li>
  <li>Application nodes and procedure nodes in the program AST are not explicitly annotated with type variables - but the type checking algorithm enforces <strong>exhaustive traversal</strong> of the AST in depth-first order.  Each time an application or procedure node is encountered, the corresponding type equation is verified, and solved in place by invoking <code class="language-plaintext highlighter-rouge">checkEqualType</code> eagerly.
Note that when we invoke <code class="language-plaintext highlighter-rouge">checkEqualType</code> - the types may <strong>not yet be known</strong>, and an expression may still be attached to an unbound TVar.   This happens for example when we infer types for the expression <code class="language-plaintext highlighter-rouge">((lambda (x) x) 1)</code> – when the operator component of this application is analyzed - there is not sufficient information to derive the type of the parameter x.  Later, when the typing rule of the application syntactic construct is applied (the top level node in the AST), the TVar associated to x will be bound to the type expression of the numeric atomic value.  This will propagate the inferred information that x is a NumTexp type from the application to the procedure expression.  This propagation of information was <strong>not</strong> necessary in the case of the type checking algorithm - because we could rely on the fact that all variable references (VarRef) are explicitly typed.</li>
  <li>We do not explicitly represent substitutions, instead we rely on the graph of TVar references as a representation of the substitution object.</li>
  <li>We do not need the explicit renaming of the program as we can rely on the TEnv mechanism to capture scoping relations.</li>
</ul>

<p>The implementation of unification through one-way variable assignment is a powerful technique, which we will revisit in Chapter 5 when we survey Logic Programming.</p>

<h2 id="summary">Summary</h2>

<ul>
  <li>We surveyed 2 implementations of the Type Inference algorithm:
    <ul>
      <li>An explicit representation of type equations and substitutions.</li>
      <li>An optimized implementation relying on one-way type variables.</li>
    </ul>
  </li>
  <li>
    <p>Both implementations rely critically on the <strong>occur-check</strong> mechanism to avoid creating circular substitutions.</p>
  </li>
  <li>The type equation algorithm operates in 3 steps:
    <ul>
      <li>Map all sub-expressions in the program to type variables and store this mapping in a pool data structure.</li>
      <li>Traverse the pool and apply the typing rules of the programming language to derive type equations for each application
and procedure nodes in the AST of the program.</li>
      <li>Solve the resulting type equations system using the unification algorithm which computes a substitution for the whole program.</li>
    </ul>
  </li>
  <li>The direct unification implemenation of this algorithm relies on <strong>one-way</strong> TVar data structure and exhaustive traversal of the AST.  Each time an application or procedure nodes are met, the corresponding type equation is eagerly solved by assigning type variables to the corresponding type expressions.</li>
</ul>



        <footer class="site-footer">
            
            <span class="site-footer-owner"><a href="https://github.com/bguppl/interpreters">interpreters</a> is maintained by <a href="https://github.com/bguppl">bguppl</a>.</span>
            
            <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com/">GitHub
                    Pages</a>.</span>
        </footer>
    </main>


<div id="give-freely-root-ejkiikneibegknkgimmihdpcbcedgmpo" class="give-freely-root" data-extension-id="ejkiikneibegknkgimmihdpcbcedgmpo" data-extension-name="Volume Booster" style="display: block;"><template shadowrootmode="open"><style>
  :host {
    all: initial;
  }

  .gf-scroll-remove::-webkit-scrollbar {
    border-radius-bottom-right: 15px;
  }

  button {
    cursor: pointer;
    transition: transform 0.1s ease;
  }

  button:active {
    transform: scale(0.98);
  }

  .give-freely-close-button:hover {
    opacity: 0.7;
  }

  input[type="radio"] {
    margin-right: 8px;
  }

  hr {
    border: none;
    border-top: 1px solid #e5e5e5;
    margin: 1em 0;
  }

  @media (max-width: 600px), (max-height: 480px) {
    #give-freely-checkout-popup {
      display: none !important;
    }
  }
</style><div><div class="gf-app"></div></div></template></div></body></html>