<!DOCTYPE html>
<!-- saved from url=(0065)https://bguppl.github.io/interpreters/practice_sessions/ps11.html -->
<html lang=" en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="module" id="truffle-injected" data-runtime="bkkjeefjfjcfdfifddmkdmcpmaakmelp" src="chrome-extension://bkkjeefjfjcfdfifddmkdmcpmaakmelp/injected-script/index.js"></script>

    
    

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ | Principles of Programming Languages</title>
<meta name="generator" content="Jekyll v3.10.0">
<meta property="og:title" content="עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’">
<meta property="og:locale" content="en_US">
<meta name="description" content="Course Website">
<meta property="og:description" content="Course Website">
<link rel="canonical" href="https://bguppl.github.io/interpreters/practice_sessions/ps11.html">
<meta property="og:url" content="https://bguppl.github.io/interpreters/practice_sessions/ps11.html">
<meta property="og:site_name" content="Principles of Programming Languages">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Course Website","headline":"עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’","url":"https://bguppl.github.io/interpreters/practice_sessions/ps11.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com/">
    <link rel="preload" href="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/css" as="style" type="text/css" crossorigin="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/style.css">
<style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style><style id="MJX-CHTML-styles">
mjx-container[jax="CHTML"] {
  line-height: 0;
}

mjx-container [space="1"] {
  margin-left: .111em;
}

mjx-container [space="2"] {
  margin-left: .167em;
}

mjx-container [space="3"] {
  margin-left: .222em;
}

mjx-container [space="4"] {
  margin-left: .278em;
}

mjx-container [space="5"] {
  margin-left: .333em;
}

mjx-container [rspace="1"] {
  margin-right: .111em;
}

mjx-container [rspace="2"] {
  margin-right: .167em;
}

mjx-container [rspace="3"] {
  margin-right: .222em;
}

mjx-container [rspace="4"] {
  margin-right: .278em;
}

mjx-container [rspace="5"] {
  margin-right: .333em;
}

mjx-container [size="s"] {
  font-size: 70.7%;
}

mjx-container [size="ss"] {
  font-size: 50%;
}

mjx-container [size="Tn"] {
  font-size: 60%;
}

mjx-container [size="sm"] {
  font-size: 85%;
}

mjx-container [size="lg"] {
  font-size: 120%;
}

mjx-container [size="Lg"] {
  font-size: 144%;
}

mjx-container [size="LG"] {
  font-size: 173%;
}

mjx-container [size="hg"] {
  font-size: 207%;
}

mjx-container [size="HG"] {
  font-size: 249%;
}

mjx-container [width="full"] {
  width: 100%;
}

mjx-box {
  display: inline-block;
}

mjx-block {
  display: block;
}

mjx-itable {
  display: inline-table;
}

mjx-row {
  display: table-row;
}

mjx-row > * {
  display: table-cell;
}

mjx-mtext {
  display: inline-block;
}

mjx-mstyle {
  display: inline-block;
}

mjx-merror {
  display: inline-block;
  color: red;
  background-color: yellow;
}

mjx-mphantom {
  visibility: hidden;
}

_::-webkit-full-page-media, _:future, :root mjx-container {
  will-change: opacity;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-math {
  display: inline-block;
  text-align: left;
  line-height: 0;
  text-indent: 0;
  font-style: normal;
  font-weight: normal;
  font-size: 100%;
  font-size-adjust: none;
  letter-spacing: normal;
  border-collapse: collapse;
  word-wrap: normal;
  word-spacing: normal;
  white-space: nowrap;
  direction: ltr;
  padding: 1px 0;
}

mjx-container[jax="CHTML"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="CHTML"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="CHTML"][display="true"] mjx-math {
  padding: 0;
}

mjx-container[jax="CHTML"][justify="left"] {
  text-align: left;
}

mjx-container[jax="CHTML"][justify="right"] {
  text-align: right;
}

mjx-msub {
  display: inline-block;
  text-align: left;
}

mjx-mi {
  display: inline-block;
  text-align: left;
}

mjx-c {
  display: inline-block;
}

mjx-utext {
  display: inline-block;
  padding: .75em 0 .2em 0;
}

mjx-mspace {
  display: inline-block;
  text-align: left;
}

mjx-mo {
  display: inline-block;
  text-align: left;
}

mjx-stretchy-h {
  display: inline-table;
  width: 100%;
}

mjx-stretchy-h > * {
  display: table-cell;
  width: 0;
}

mjx-stretchy-h > * > mjx-c {
  display: inline-block;
  transform: scalex(1.0000001);
}

mjx-stretchy-h > * > mjx-c::before {
  display: inline-block;
  width: initial;
}

mjx-stretchy-h > mjx-ext {
  /* IE */ overflow: hidden;
  /* others */ overflow: clip visible;
  width: 100%;
}

mjx-stretchy-h > mjx-ext > mjx-c::before {
  transform: scalex(500);
}

mjx-stretchy-h > mjx-ext > mjx-c {
  width: 0;
}

mjx-stretchy-h > mjx-beg > mjx-c {
  margin-right: -.1em;
}

mjx-stretchy-h > mjx-end > mjx-c {
  margin-left: -.1em;
}

mjx-stretchy-v {
  display: inline-block;
}

mjx-stretchy-v > * {
  display: block;
}

mjx-stretchy-v > mjx-beg {
  height: 0;
}

mjx-stretchy-v > mjx-end > mjx-c {
  display: block;
}

mjx-stretchy-v > * > mjx-c {
  transform: scaley(1.0000001);
  transform-origin: left center;
  overflow: hidden;
}

mjx-stretchy-v > mjx-ext {
  display: block;
  height: 100%;
  box-sizing: border-box;
  border: 0px solid transparent;
  /* IE */ overflow: hidden;
  /* others */ overflow: visible clip;
}

mjx-stretchy-v > mjx-ext > mjx-c::before {
  width: initial;
  box-sizing: border-box;
}

mjx-stretchy-v > mjx-ext > mjx-c {
  transform: scaleY(500) translateY(.075em);
  overflow: visible;
}

mjx-mark {
  display: inline-block;
  height: 0px;
}

mjx-TeXAtom {
  display: inline-block;
  text-align: left;
}

mjx-mn {
  display: inline-block;
  text-align: left;
}

mjx-c::before {
  display: block;
  width: 0;
}

.MJX-TEX {
  font-family: MJXZERO, MJXTEX;
}

.TEX-B {
  font-family: MJXZERO, MJXTEX-B;
}

.TEX-I {
  font-family: MJXZERO, MJXTEX-I;
}

.TEX-MI {
  font-family: MJXZERO, MJXTEX-MI;
}

.TEX-BI {
  font-family: MJXZERO, MJXTEX-BI;
}

.TEX-S1 {
  font-family: MJXZERO, MJXTEX-S1;
}

.TEX-S2 {
  font-family: MJXZERO, MJXTEX-S2;
}

.TEX-S3 {
  font-family: MJXZERO, MJXTEX-S3;
}

.TEX-S4 {
  font-family: MJXZERO, MJXTEX-S4;
}

.TEX-A {
  font-family: MJXZERO, MJXTEX-A;
}

.TEX-C {
  font-family: MJXZERO, MJXTEX-C;
}

.TEX-CB {
  font-family: MJXZERO, MJXTEX-CB;
}

.TEX-FR {
  font-family: MJXZERO, MJXTEX-FR;
}

.TEX-FRB {
  font-family: MJXZERO, MJXTEX-FRB;
}

.TEX-SS {
  font-family: MJXZERO, MJXTEX-SS;
}

.TEX-SSB {
  font-family: MJXZERO, MJXTEX-SSB;
}

.TEX-SSI {
  font-family: MJXZERO, MJXTEX-SSI;
}

.TEX-SC {
  font-family: MJXZERO, MJXTEX-SC;
}

.TEX-T {
  font-family: MJXZERO, MJXTEX-T;
}

.TEX-V {
  font-family: MJXZERO, MJXTEX-V;
}

.TEX-VB {
  font-family: MJXZERO, MJXTEX-VB;
}

mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c {
  font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A ! important;
}

@font-face /* 0 */ {
  font-family: MJXZERO;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff");
}

@font-face /* 1 */ {
  font-family: MJXTEX;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff");
}

@font-face /* 2 */ {
  font-family: MJXTEX-B;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff");
}

@font-face /* 3 */ {
  font-family: MJXTEX-I;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff");
}

@font-face /* 4 */ {
  font-family: MJXTEX-MI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff");
}

@font-face /* 5 */ {
  font-family: MJXTEX-BI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff");
}

@font-face /* 6 */ {
  font-family: MJXTEX-S1;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff");
}

@font-face /* 7 */ {
  font-family: MJXTEX-S2;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff");
}

@font-face /* 8 */ {
  font-family: MJXTEX-S3;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff");
}

@font-face /* 9 */ {
  font-family: MJXTEX-S4;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff");
}

@font-face /* 10 */ {
  font-family: MJXTEX-A;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff");
}

@font-face /* 11 */ {
  font-family: MJXTEX-C;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff");
}

@font-face /* 12 */ {
  font-family: MJXTEX-CB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff");
}

@font-face /* 13 */ {
  font-family: MJXTEX-FR;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff");
}

@font-face /* 14 */ {
  font-family: MJXTEX-FRB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff");
}

@font-face /* 15 */ {
  font-family: MJXTEX-SS;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff");
}

@font-face /* 16 */ {
  font-family: MJXTEX-SSB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff");
}

@font-face /* 17 */ {
  font-family: MJXTEX-SSI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff");
}

@font-face /* 18 */ {
  font-family: MJXTEX-SC;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff");
}

@font-face /* 19 */ {
  font-family: MJXTEX-T;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff");
}

@font-face /* 20 */ {
  font-family: MJXTEX-V;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff");
}

@font-face /* 21 */ {
  font-family: MJXTEX-VB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff");
}

mjx-c.mjx-c1D461.TEX-I::before {
  padding: 0.626em 0.361em 0.011em 0;
  content: "t";
}

mjx-c.mjx-c1D456.TEX-I::before {
  padding: 0.661em 0.345em 0.011em 0;
  content: "i";
}

mjx-c.mjx-c210E.TEX-I::before {
  padding: 0.694em 0.576em 0.011em 0;
  content: "h";
}

mjx-c.mjx-c1D452.TEX-I::before {
  padding: 0.442em 0.466em 0.011em 0;
  content: "e";
}

mjx-c.mjx-c1D44E.TEX-I::before {
  padding: 0.441em 0.529em 0.01em 0;
  content: "a";
}

mjx-c.mjx-c1D451.TEX-I::before {
  padding: 0.694em 0.52em 0.01em 0;
  content: "d";
}

mjx-c.mjx-c3A::before {
  padding: 0.43em 0.278em 0 0;
  content: ":";
}

mjx-c.mjx-c2212::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "\2212";
}

mjx-c.mjx-c1D44F.TEX-I::before {
  padding: 0.694em 0.429em 0.011em 0;
  content: "b";
}

mjx-c.mjx-c1D45C.TEX-I::before {
  padding: 0.441em 0.485em 0.011em 0;
  content: "o";
}

mjx-c.mjx-c1D466.TEX-I::before {
  padding: 0.442em 0.49em 0.205em 0;
  content: "y";
}

mjx-c.mjx-c2E::before {
  padding: 0.12em 0.278em 0 0;
  content: ".";
}

mjx-c.mjx-c1D45F.TEX-I::before {
  padding: 0.442em 0.451em 0.011em 0;
  content: "r";
}

mjx-c.mjx-c1D462.TEX-I::before {
  padding: 0.442em 0.572em 0.011em 0;
  content: "u";
}

mjx-c.mjx-c1D459.TEX-I::before {
  padding: 0.694em 0.298em 0.011em 0;
  content: "l";
}

mjx-c.mjx-c1D460.TEX-I::before {
  padding: 0.442em 0.469em 0.01em 0;
  content: "s";
}

mjx-c.mjx-c3D::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "=";
}

mjx-c.mjx-c52::before {
  padding: 0.683em 0.736em 0.022em 0;
  content: "R";
}

mjx-c.mjx-c73::before {
  padding: 0.448em 0.394em 0.011em 0;
  content: "s";
}

mjx-c.mjx-c65::before {
  padding: 0.448em 0.444em 0.011em 0;
  content: "e";
}

mjx-c.mjx-c6C::before {
  padding: 0.694em 0.278em 0 0;
  content: "l";
}

mjx-c.mjx-c28::before {
  padding: 0.75em 0.389em 0.25em 0;
  content: "(";
}

mjx-c.mjx-c47::before {
  padding: 0.705em 0.785em 0.022em 0;
  content: "G";
}

mjx-c.mjx-c2C::before {
  padding: 0.121em 0.278em 0.194em 0;
  content: ",";
}

mjx-c.mjx-c50::before {
  padding: 0.683em 0.681em 0 0;
  content: "P";
}

mjx-c.mjx-c29::before {
  padding: 0.75em 0.389em 0.25em 0;
  content: ")";
}

mjx-c.mjx-c27E8::before {
  padding: 0.75em 0.389em 0.25em 0;
  content: "\27E8";
}

mjx-c.mjx-c27E9::before {
  padding: 0.75em 0.389em 0.25em 0;
  content: "\27E9";
}

mjx-c.mjx-c2208::before {
  padding: 0.54em 0.667em 0.04em 0;
  content: "\2208";
}

mjx-c.mjx-c68::before {
  padding: 0.694em 0.556em 0 0;
  content: "h";
}

mjx-c.mjx-c61::before {
  padding: 0.448em 0.5em 0.011em 0;
  content: "a";
}

mjx-c.mjx-c64::before {
  padding: 0.694em 0.556em 0.011em 0;
  content: "d";
}

mjx-c.mjx-c1D45B.TEX-I::before {
  padding: 0.442em 0.6em 0.011em 0;
  content: "n";
}

mjx-c.mjx-c1D43A.TEX-I::before {
  padding: 0.705em 0.786em 0.022em 0;
  content: "G";
}

mjx-c.mjx-c31::before {
  padding: 0.666em 0.5em 0 0;
  content: "1";
}

mjx-c.mjx-c6E::before {
  padding: 0.442em 0.556em 0 0;
  content: "n";
}

mjx-c.mjx-c2265::before {
  padding: 0.636em 0.778em 0.138em 0;
  content: "\2265";
}

mjx-c.mjx-c1D435.TEX-I::before {
  padding: 0.683em 0.759em 0 0;
  content: "B";
}

mjx-c.mjx-c1D45A.TEX-I::before {
  padding: 0.442em 0.878em 0.011em 0;
  content: "m";
}

mjx-c.mjx-c2B::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "+";
}

mjx-c.mjx-c1D70E.TEX-I::before {
  padding: 0.431em 0.571em 0.011em 0;
  content: "\3C3";
}
</style></head>

<body>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async="" src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/tex-mml-chtml.js.download"></script>

    <header class="page-header" role="banner">
        <h1 class="project-name">Principles of Programming Languages</h1>
        <h2 class="project-tagline">Course Website</h2>
        
        <a href="https://github.com/bguppl/interpreters" class="btn">View on GitHub</a>
        
        
    </header>

    <main id="content" class="main-content" role="main">
        <h1 id="עקרונות-שפות-תכנות--אביב-2021תרגול-11-תכנות-לוגי--חלק-א">עקרונות שפות תכנות – אביב 2021<br>תרגול 11. תכנות לוגי – חלק א’</h1>

<ul>
  <li><a href="https://bguppl.github.io/interpreters/practice_sessions/ps11.html#0-%D7%A9%D7%99%D7%9E%D7%95%D7%A9-%D7%91-swi-%D7%A4%D7%A8%D7%95%D7%9C%D7%95%D7%92">0. שימוש ב-SWI פרולוג</a></li>
  <li><a href="https://bguppl.github.io/interpreters/practice_sessions/ps11.html#1-%D7%9E%D7%91%D7%95%D7%90-%D7%9C%D7%AA%D7%9B%D7%A0%D7%95%D7%AA-%D7%94%D7%9C%D7%95%D7%92%D7%99-%D7%94%D7%A8%D7%9C%D7%A6%D7%99%D7%95%D7%A0%D7%99">1. מבוא לתכנות הלוגי הרלציוני</a></li>
  <li><a href="https://bguppl.github.io/interpreters/practice_sessions/ps11.html#2-%D7%A1%D7%9E%D7%A0%D7%98%D7%99%D7%A7%D7%94-%D7%90%D7%9C%D7%92%D7%95%D7%A8%D7%99%D7%AA%D7%9D-%D7%99%D7%95%D7%A0%D7%99%D7%A4%D7%99%D7%A7%D7%A6%D7%99%D7%94-%D7%A2%D7%A6%D7%99-%D7%94%D7%95%D7%9B%D7%97%D7%94">2. סמנטיקה: אלגוריתם יוניפיקציה, עצי הוכחה</a>
    <ul>
      <li><a href="https://bguppl.github.io/interpreters/practice_sessions/ps11.html#21-%D7%90%D7%9C%D7%92%D7%95%D7%A8%D7%99%D7%AA%D7%9D-%D7%99%D7%95%D7%A0%D7%99%D7%A4%D7%99%D7%A7%D7%A6%D7%99%D7%94-%D7%A2%D7%91%D7%95%D7%A8-%D7%AA%D7%9B%D7%A0%D7%95%D7%AA-%D7%9C%D7%95%D7%92%D7%99-%D7%A8%D7%9C%D7%A6%D7%99%D7%95%D7%A0%D7%99">2.1 אלגוריתם יוניפיקציה עבור תכנות לוגי רלציוני</a></li>
      <li><a href="https://bguppl.github.io/interpreters/practice_sessions/ps11.html#22-%D7%A2%D7%A6%D7%99-%D7%94%D7%95%D7%9B%D7%97%D7%94-%D7%94%D7%A4%D7%A2%D7%9C%D7%AA-%D7%94%D7%90%D7%9C%D7%92%D7%95%D7%A8%D7%99%D7%AA%D7%9D-answer-query">2.2 עצי הוכחה (הפעלת האלגוריתם answer-query)</a></li>
      <li><a href="https://bguppl.github.io/interpreters/practice_sessions/ps11.html#23-%D7%A1%D7%95%D7%92%D7%99-%D7%94%D7%A8%D7%A7%D7%95%D7%A8%D7%A1%D7%99%D7%94">2.3 סוגי הרקורסיה</a></li>
    </ul>
  </li>
  <li><a href="https://bguppl.github.io/interpreters/practice_sessions/ps11.html#3-logic-programming">3. Logic Programming</a></li>
</ul>

<p><strong>נושאים:</strong></p>
<ol>
  <li>מבוא לתכנות הלוגי הרלציוני.</li>
  <li>סמנטיקה: אלגוריתם יוניפיקציה, עצי הוכחה.</li>
  <li>תכנות לוגי, פנקטורים.</li>
</ol>

<h2 id="0-שימוש-ב-swi-פרולוג">0. שימוש ב-SWI פרולוג</h2>
<p>בחלק הזה של הקורס תשתמשו בתוכנת SWI, אינטרפרטר של שפת תכנות Prolog העובד בצורת read-evaluate-print. תוכלו
<a href="http://www.swi-prolog.org/download/stable">להוריד</a>
אותה מהרשת ולהריץ התקנה אוטומטית. לאחר הפתיחה תראו את המסך הבא:</p>

<p class="c"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/image1.png" alt=""></p>
<p>שם ניתן להקליד שאילתות. כדי לטעון קובץ, ניתן להשתמש בתפריט File -&gt; Consult.</p>

<p>למטרות דיבוג ניתן להשתמש בפרוצדורה <code class="language-plaintext highlighter-rouge">writeln</code>, שמקבלת פרמטר אחד – תוכן להדפסה. למשל, כדי לדעת מהו הערך של משתנה X בנקודה מסויימת בתוכנית, מוסיפים שם <code class="language-plaintext highlighter-rouge">writeln(X)</code>.</p>

<h2 id="1-מבוא-לתכנות-הלוגי-הרלציוני">1. מבוא לתכנות הלוגי הרלציוני</h2>
<p><strong><u>מושגים:</u></strong></p>
<ol>
  <li><u>פרוצדורה</u> היא קבוצה סדורה של אקסיומות (עובדות וכללים) עם חתימה זהה, הכוללת את שם הפרדיקט ומספר הפרמטרים (arity).</li>
  <li><u>תוכנית לוגית</u> היא קבוצה לא סדורה של פרוצדורות (פרדיקטים), המגדירות יחסים בתחום ההגדרה של התוכנה.</li>
  <li>האינטרפרטר של פרולוג עובד בלולאת read-eval-print. בהינתן שאילתה, הוא מנסה להוכיח אותה על סמך התוכנית:
    <ul>
      <li>אם נכשל, עונה False (או No).</li>
      <li>אם הצליח, והשאילתה לא כוללת משתנים, התשובה היא True (או Yes). (למשל, בשאילתה “טעינת קובץ”.)</li>
      <li>אם הצליח, והשאילתה כוללת משתנים, מציג את כל ההצבות של המשתנים של השאילתה שחושבו בבניית ההוכחה.</li>
    </ul>
  </li>
</ol>

<p><strong>דוגמה 1: תזכורת.</strong><br>
נזכר תחילה בדוגמה שראינו בכיתה. נתונה תוכנית</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">parent</span><span class="p">(</span><span class="ss">abraham</span><span class="p">,</span> <span class="ss">isaac</span><span class="p">).</span>
<span class="ss">parent</span><span class="p">(</span><span class="ss">isaac</span><span class="p">,</span> <span class="ss">jacob</span><span class="p">).</span>
<span class="ss">parent</span><span class="p">(</span><span class="ss">sarah</span><span class="p">,</span> <span class="ss">isaac</span><span class="p">).</span>
<span class="ss">parent</span><span class="p">(</span><span class="ss">jacob</span><span class="p">,</span> <span class="ss">joseph</span><span class="p">).</span>

<span class="ss">male</span><span class="p">(</span><span class="ss">abraham</span><span class="p">).</span>
<span class="ss">male</span><span class="p">(</span><span class="ss">isaac</span><span class="p">).</span>
<span class="ss">male</span><span class="p">(</span><span class="ss">joseph</span><span class="p">).</span>

<span class="ss">female</span><span class="p">(</span><span class="ss">sarah</span><span class="p">).</span>

<span class="ss">mother</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">parent</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="ss">female</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>

<span class="c1">% Signature: ancestor(Ancestor, Descendant)/2</span>
<span class="c1">% Purpose: Ancestor is an ancestor of Descendant.</span>
<span class="ss">ancestor</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">D</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">parent</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">D</span><span class="p">).</span>                  <span class="c1">%1</span>
<span class="ss">ancestor</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">D</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">parent</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">P</span><span class="p">),</span> <span class="ss">ancestor</span><span class="p">(</span><span class="nv">P</span><span class="p">,</span><span class="nv">D</span><span class="p">).</span>   <span class="c1">%2</span>
</code></pre></div></div>

<p>נריץ בפרולוג את השאילתות הבאות:</p>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">parent</span><span class="p">(</span><span class="ss">abraham</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">isaac</span><span class="p">.</span>

<span class="o">?-</span> <span class="ss">ancestor</span><span class="p">(</span><span class="ss">abraham</span><span class="p">,</span> <span class="nv">D</span><span class="p">).</span>
<span class="nv">D</span> <span class="o">=</span> <span class="ss">isaac</span><span class="p">;</span>
<span class="nv">D</span> <span class="o">=</span> <span class="ss">jacob</span><span class="p">;</span>
<span class="nv">D</span> <span class="o">=</span> <span class="ss">joseph</span><span class="p">;</span>
<span class="ss">false</span>
</code></pre></div></div>

<p><strong>דוגמה 2:</strong><br>
תוכנית למידול מעגלים לוגיים חשמליים. אנו נמדל מעגלים לוגיים באמצעות שימוש בנקודות החיבור כ”אובייקטים” (קבועים ומשתנים) בתוכנית. בתכנות לוגי מטרתנו איננה חישוב תוצאה של פונקציה, אלא בדיקת שאילתות: למשל, האם יש מעגל מסוים במערכת, ואם כן, אילו נקודות הוא כולל.</p>

<p class="c"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/image2.png" alt=""></p>

<p><u>הגדרות:</u></p>
<ol>
  <li><u>רכיב חשמלי</u> הוא התקן פרימיטיבי במערכת, שמחבר מספר נקודות. נשתמש בשני סוגי רכיבים חשמליים: נגד וטרנזיסטור.</li>
  <li><u>נקודת חיבור</u> היא נקודה שאפשר לחברה לרכיב חשמלי. ישנם שלושה סוגי נקודות חיבור: נקודת הלחמה (שמקשרת שני רכיבים), נקודת מתח ונקודת הארקה. למשל, הציור לעיל מראה נקודות הלחמה n₁,‏ …,‏ n₅, שתי נקודות מתח ושתי נקודות הארקה.</li>
  <li><u>נגד</u> (resistor) הוא רכיב בעל שני חיבורים. הוא סימטרי, לכן אין משמעות לסדר החיבורים. בציור מודגש באליפסה נגד המחבר נקודת מתח ונקודה n₂.</li>
  <li><u>טרנזיסטור</u> הוא רכיב בעל שלושה חיבורים, כשלכל חיבור משמעות מיוחדת. אנו נתייחס לחיבורים בסדר ימין-למטה-למעלה בציור. למשל, בטרנזיסטור המוקף בעיגול, הסדר הוא ,n₂ אז ground, ובסוף n₁.</li>
  <li><u>מעגל לוגי</u> הוא חיבור של כמה רכיבים חשמליים, המממש פונקציה לוגית.</li>
</ol>

<p>כדי למדל את הבעיה באמצעות יחסים בתכנות לוגי, נשתמש בשיטה הידועה
כ-“Components and connectors modeling”. בעצם, התוכנית שאנו כותבים תייצג גרף כבסיס נתונים, ללא קשר למשמעות החשמלית של הדוגמה.</p>

<p>המערכת כוללת שני סוגי components: נגד וטרנזיסטור. ה-connectors הם power, ground, n1, n2, n3, n4, n5. נגד הוא component שכוללת שני connectors, ואנו מתארים אותה בתור יחס:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">resistor</span><span class="p">(</span><span class="nv">End1</span><span class="p">,</span> <span class="nv">End2</span><span class="p">)</span>
</code></pre></div></div>

<p>טרנזיסטור הוא component המשלב 3 connectors, כשכל אחד משחק תפקיד משלו, ואנו מתארים אותו בתור יחס:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">transistor</span><span class="p">(</span><span class="nv">Gate</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Drain</span><span class="p">)</span>
</code></pre></div></div>

<p>את כל התמונה ניתן להציג באמצעות תוכנית:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: resistor(End1, End2)/2</span>
<span class="c1">% Purpose: resistor gate</span>
<span class="ss">resistor</span><span class="p">(</span><span class="ss">power</span><span class="p">,</span> <span class="ss">n1</span><span class="p">).</span>                <span class="c1">%1</span>
<span class="ss">resistor</span><span class="p">(</span><span class="ss">power</span><span class="p">,</span> <span class="ss">n2</span><span class="p">).</span>                <span class="c1">%2</span>
<span class="ss">resistor</span><span class="p">(</span><span class="ss">n1</span><span class="p">,</span> <span class="ss">power</span><span class="p">).</span>                <span class="c1">%3</span>
<span class="ss">resistor</span><span class="p">(</span><span class="ss">n2</span><span class="p">,</span> <span class="ss">power</span><span class="p">).</span>                <span class="c1">%4</span>
</code></pre></div></div>

<p>מכיוון שנגד הוא יחס סימטרי, מייצגים כל נגד באמצעות שתי עובדות, אחת לכל כיוון.</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: transistor(Gate, Source, Drain)/3</span>
<span class="c1">% Purpose: transistor gate</span>
<span class="ss">transistor</span><span class="p">(</span><span class="ss">n2</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="ss">n1</span><span class="p">).</span>             <span class="c1">%1</span>
<span class="ss">transistor</span><span class="p">(</span><span class="ss">n3</span><span class="p">,</span> <span class="ss">n4</span><span class="p">,</span> <span class="ss">n2</span><span class="p">).</span>                 <span class="c1">%2</span>
<span class="ss">transistor</span><span class="p">(</span><span class="ss">n5</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="ss">n4</span><span class="p">).</span>             <span class="c1">%3</span>
</code></pre></div></div>

<div class="av">
  <p><strong><u>תזכורת להגדרות והסברים:</u></strong></p>
  <ol>
    <li>כל פרוצדורה מתחילה בחוזה המכיל שני חלקים: חתימה (הכוללת <strong><em>arity</em></strong>) ומטרה.</li>
    <li>power,‏ n1,‏ ground הם <strong><em>קבועים</em></strong>. עליהם להתחיל באות קטנה.</li>
    <li>resistor הוא <strong><em>שם הפרדיקט</em></strong>. הוא מגדיר <strong><em>יחס</em></strong> בין שני הארגומנטים שלו. גם הוא קבוע.</li>
    <li><strong><em>נוסחה אטומית</em></strong> היא מבנה בצורה predicate(t₁, …, tₙ), כאשר <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="0" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>t</mi><mi>i</mi></msub></math></mjx-assistive-mml></mjx-container> הוא <strong><em>term</em></strong> (קבוע או משתנה).</li>
    <li>אם n=0, נוסחה ללא משתנים, לא כותבים גם את הסוגריים. שתי דוגמאות לנוסחה כזאת הן מובנות בשפה (built-in): true – תמיד מצליח, false – תמיד נכשל.</li>
    <li><strong><em>כלל</em></strong> הוא נוסחה שמגדירה יחס התלוי בתנאים מסוימים, כלומר, הכלל “<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="1" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c210E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mstyle><mjx-mspace style="width: 0.278em;"></mjx-mspace></mjx-mstyle><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3A"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mstyle><mjx-mspace style="width: 0.278em;"></mjx-mspace></mjx-mstyle><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45C TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mstyle scriptlevel="0"><mspace width="0.278em"></mspace></mstyle><mo>:</mo><mo>−</mo><mstyle scriptlevel="0"><mspace width="0.278em"></mspace></mstyle><mi>b</mi><mi>o</mi><mi>d</mi><mi>y</mi><mo>.</mo></math></mjx-assistive-mml></mjx-container>” שקול לגרירה head←body.</li>
    <li><strong><em>עובדה</em></strong> היא הגדרת יחס שנכון ללא כל תנאי. עובדה היא מקרה פרטי של כלל: כאשר הגוף תמיד נכון, הנוסחה האטומית true וסימן הגרירה -: לא נכתבים.</li>
    <li><strong><em>שאילתה</em></strong> היא סדרה של נוסחאות אטומיות.</li>
  </ol>

  <div class="pr">
    <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">resistor</span><span class="p">(</span><span class="ss">power</span><span class="p">,</span> <span class="ss">n1</span><span class="p">),</span> <span class="ss">resistor</span><span class="p">(</span><span class="ss">n2</span><span class="p">,</span> <span class="ss">power</span><span class="p">).</span>
<span class="ss">true</span> <span class="p">;</span>
<span class="ss">false</span>
</code></pre></div>    </div>

    <p class="s1"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/image3.png" alt=""></p>
    <p class="s2">אין יותר תשובות</p>
  </div>
</div>

<ol start="9"><li>
    <p><strong><em>משתנים</em></strong> מתחילים באותיות גדולות. משתנה בשם _ הינו משתנה חד פעמי (wildcard).</p>
  </li></ol>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">resistor</span><span class="p">(</span><span class="ss">power</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">n1</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">n2</span>
</code></pre></div></div>

<p class="ind"><em>“האם קיים X, כך שהזוג (power, X) יכול להתאים ליחס הנגד?”</em></p>

<p>נוסחה בשאילתה יכולה להצליח (אם יש לפחות הצבה אחת שמתאימה להוכחה), או להיכשל.
כל עוד קיימות אפשרויות, פרולוג עונה תשובה אחת. המשתמש יכול ללחוץ “;” כדי להמשיך לתשובה הבאה, או “Enter” כדי לסיים.<br>
המשתנים בשאילתה מכומתים כמשתני “קיים” (<strong>existentially quantified</strong>).</p>

<p><strong>מעגלים לוגיים.</strong></p>

<p>חיבור כמה רכיבים בדרך מסוימת יוצר מעגל לוגי. למשל, מעגל לוגי not:</p>

<p class="c"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/image4.png" alt=""></p>

<div class="av">
  <p>הוא נוצר ע”י חיבור נגד עם טרנזיסטור בדרך המצוינת בציור. הנקודה n2 היא קלט, n1 היא פלט.
מעגל לוגי מממש פונקציה בוליאנית שערכה נקבע על ידי צירופים של טרנזיסטורים, נגדים ומעגלים. אפשר לתארו כיחס בין נקודות קלט ופלט. ערך נקודת הפלט נקבע על ידי ערך נקודות הקלט, ומבנה הצירופים במעגל. כל מבנה של צירופים קובע סוג של מעגל. לכן, אפשר לתאר כל סוג של מעגל כיחס התלוי במבנה הצירופים. בפרולוג זה מתואר על ידי כללים. אנו מבחינים ביחס חדש בין קלט לפלט:</p>

  <div class="pr">
    <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: not_circuit(Input, Output)/2</span>
<span class="c1">% Purpose: logic circuit of not.</span>
<span class="ss">not_circuit</span><span class="p">(</span><span class="nv">Input</span><span class="p">,</span> <span class="nv">Output</span><span class="p">)</span> <span class="p">:-</span>                                    <span class="c1">%1</span>
	<span class="ss">transistor</span><span class="p">(</span><span class="nv">Input</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="nv">Output</span><span class="p">),</span>
	<span class="ss">resistor</span><span class="p">(</span><span class="ss">power</span><span class="p">,</span> <span class="nv">Output</span><span class="p">).</span>
</code></pre></div>    </div>

    <p class="s3"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/image5.png" alt=""></p>
    <p class="s4"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/image6.png" alt=""></p>
    <p class="s5"><strong><em>גוף</em></strong> הכלל:<br>
“,” פרושו “וגם”</p>
    <p class="s6"><strong><em>ראש</em></strong> הכלל – נוסחה אטומית</p>
  </div>
</div>

<p><br>המשתנים בכלל מכומתים על ידי “לכל” (<strong>universally quantified</strong>) על טווח כל הכלל.</p>

<p><em>“לכל Input ולכל Output, הזוג (Input, Output) מקיים יחס not_circuit, אם השלישייה (Input, ground, Output) מקיימת יחס טרנזיסטור והזוג (power, Output) מקיים יחס נגד.”</em></p>

<p>בציור הראשון קיים רק מעגל אחד כזה:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">not_circuit</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">n2</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">n1</span>
</code></pre></div></div>
<p>מעגל לוגי nand מתואר בציור הבא (קלטים מימין, פלט משמאל).</p>

<p class="c"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/image7.png" alt=""></p>

<p>אנו מבחינים ביחס חדש בין שני קלטים לפלט:</p>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: nand_circuit(Input1, Input2, Output)/3</span>
<span class="c1">% Purpose: logic circuit of nand</span>
<span class="ss">nand_circuit</span><span class="p">(</span><span class="nv">Input1</span><span class="p">,</span> <span class="nv">Input2</span><span class="p">,</span> <span class="nv">Output</span><span class="p">)</span> <span class="p">:-</span>                <span class="c1">%1</span>
	<span class="ss">transistor</span><span class="p">(</span><span class="nv">Input1</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Output</span><span class="p">),</span>
	<span class="ss">transistor</span><span class="p">(</span><span class="nv">Input2</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span>
	<span class="ss">resistor</span><span class="p">(</span><span class="ss">power</span><span class="p">,</span> <span class="nv">Output</span><span class="p">).</span>
</code></pre></div></div>

<p>ניתן להתייחס למשתנים המופיעים רק בגוף הכלל כמשתני “קיים” (<strong>existentially quantified</strong>)<br>
<em>“כל Input1, Input2 ו-Output מקיימים יחס של מעגל לוגי nand_circuit אם <u>קיים</u> X כך ש…”</em><br>
נוכל לבדוק האם קיים יחס and במערכת:</p>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">not_circuit</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="ss">nand_circuit</span><span class="p">(</span><span class="nv">In1</span><span class="p">,</span> <span class="nv">In2</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">n2</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">n1</span><span class="p">,</span>
<span class="nv">In1</span> <span class="o">=</span> <span class="ss">n3</span><span class="p">,</span>
<span class="nv">In2</span> <span class="o">=</span> <span class="ss">n5</span> <span class="p">;</span>
<span class="ss">false</span>
</code></pre></div></div>

<p>ניתן להריץ בתוכנת SWI סביבת דיבוג גרפי, למשל</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">gtrace</span><span class="p">,</span> <span class="ss">not_circuit</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="ss">nand_circuit</span><span class="p">(</span><span class="nv">In1</span><span class="p">,</span> <span class="nv">In2</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p>בסיום העבודה ניתן לכבותה באמצעות הפקודה</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">nodebug</span><span class="p">.</span>
</code></pre></div></div>

<p>ייתכן כי בעתיד נצטרך להריץ שאילתה כזאת שוב, על קלט אחר. לכן כדאי להפוך אותה לכלל:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: and_circuit(Input1, Input2, Output)/3</span>
<span class="c1">% Purpose: logic circuit of and</span>
<span class="ss">and_circuit</span><span class="p">(</span><span class="nv">Input1</span><span class="p">,</span> <span class="nv">Input2</span><span class="p">,</span> <span class="nv">Output</span><span class="p">)</span> <span class="p">:-</span>                   <span class="c1">%1</span>
	<span class="ss">not_circuit</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Output</span><span class="p">),</span>
	<span class="ss">nand_circuit</span><span class="p">(</span><span class="nv">Input1</span><span class="p">,</span> <span class="nv">Input2</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>

<p class="c"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/image8.png" alt=""></p>

<h2 id="2-סמנטיקה-אלגוריתם-יוניפיקציה-עצי-הוכחה">2. סמנטיקה: אלגוריתם יוניפיקציה, עצי הוכחה</h2>
<h3 id="21-אלגוריתם-יוניפיקציה-עבור-תכנות-לוגי-רלציוני">2.1 אלגוריתם יוניפיקציה עבור תכנות לוגי רלציוני</h3>

<p>כדי למצוא הוכחה אפשרית לשאילתה, האלגוריתם answer-query עושה ניסיונות מרובים להפעיל כללים על יעד נבחר (goal). זה נעשה בעזרת אלגוריתם יוניפיקציה, Unify, על ראש הכלל והיעד.</p>

<p><strong><u>הגדרות:</u></strong></p>
<ul>
  <li><strong><em>binding</em></strong> הוא ביטוי לא מעגלי מהסוג <code class="language-plaintext highlighter-rouge">X=t</code>, כאשר X הוא משתנה, t הוא term,‏ t אינו כולל את X.</li>
  <li><strong><em>הצבה</em></strong> (substitution) היא פונקציה מקבוצה סופית של משתנים לקבוצה סופית של ביטויים (terms). (אפשר לחשוב על הצבה כעל קבוצה סופית של bindings ללא חזרות של משתנים).</li>
  <li><strong><em>הפעלה</em></strong> של הצבה על נוסחה אטומית:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = not_circuit(I, I) , B = not_circuit(X, Y), s={I=X}:
A ∘ s = not_circuit(I, I) ∘ s = not_circuit(X, X)
B ∘ s = not_circuit(X, Y)
</code></pre></div>    </div>
  </li>
  <li><strong><em>הרכבה</em></strong> של הצבות:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s = {I=X} ∘ {X=Y} = {I=Y, X=Y}
</code></pre></div>    </div>
  </li>
  <li>הצבה s נקראת <strong><em>unifier</em></strong> של נוסחאות A,‏ B, אם הפעלתה על שתיהן נותנת תוצאה זהה. לדוגמה:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s = {I=Y, X=Y}
A ∘ s = not_circuit(Y, Y)
B ∘ s = not_circuit(Y, Y)
</code></pre></div>    </div>
  </li>
</ul>

<p>אלגוריתם Unify שנלמד בהרצאה מקבל שתי נוסחאות אטומיות ומחזיר unifier כללי ביותר שלהן (mgu, most general unifier).<br>
במקרה הנ”ל, נקבל <code class="language-plaintext highlighter-rouge">s={I=Y, X=Y}</code>. קיימות אפשרויות נוספות, כלליות פחות, כמו <code class="language-plaintext highlighter-rouge">s={I=5, X=5, Y=5}</code>.</p>

<p>דוגמה נוספת:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = some(B, 3, C), B = some(A, B, D), s={A=3, B=3, C=D}.
</code></pre></div></div>

<p>יש לשים לב, שמספר הוא סמל קבוע, ואיננו מחושב כמספר. מבחינת המשמעות, 345 הוא סמל (שם) ולא מספר.</p>

<div class="av">
  <h3 id="answer-query">2.2 עצי הוכחה (הפעלת האלגוריתם answer-query)</h3>
  <p>האינטרפרטר מחפש הוכחה לשאילתה נתונה באמצעות בנייה וסקירה של עץ ההוכחה, בו כל האפשרויות נלקחות בחשבון.</p>
</div>
<p>מבנה העץ תלוי במדיניות בחירת המטרה ובחירת הכלל. תיאור האלגוריתם מופיע בספר, כשחלקו אפשר לראות כאן:</p>

<hr>
<div class="l">
  <p class="courier">proof-tree:</p>
  <p><strong>if</strong> <em>label(node)</em> is <em>?- true, . . . , true.</em><br>
<strong>then</strong></p>
  <ol>
    <li>Mark <strong>node</strong> as a <strong>Success</strong> node (leaf). A <strong>success backtracking point</strong>.</li>
    <li><em>answers</em> := <em>answers</em> ∪ {<em>s₁</em> ○ <em>s₂</em> ○ … ○ <em>sₙ</em>}, where <em>s₁</em>, … , <em>sₙ</em> are the substitution labels of the path from the tree-root to <em>node</em>. Mark <em>node</em> with this substitution.</li>
  </ol>

  <p><strong>else</strong></p>
  <ol>
    <li><strong>Goal selection</strong>: <em>G = Gsel(label(node))</em>. <em>G ≠ true</em> since <em>Gsel</em> does not select a <em>true</em> goal.</li>
    <li><strong>Variables renaming</strong>: Rename variables in every rule and fact of P (justified since all variables are universally quantified, i.e., bound).</li>
    <li><strong>Rule selection</strong>: <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="2" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D462 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D460 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mi class="mjx-n" space="4"><mjx-c class="mjx-c52"></mjx-c><mjx-c class="mjx-c73"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6C"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-n"><mjx-c class="mjx-c47"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-n" space="2"><mjx-c class="mjx-c50"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c27E8"></mjx-c></mjx-mo><mjx-mi class="mjx-n"><mjx-c class="mjx-c52"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-n" space="2"><mjx-utext variant="normal" style="font-size: 85.2%; padding: 0.881em 0px 0.235em; font-family: MJXZERO, serif;">σ</mjx-utext></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c27E9"></mjx-c></mjx-mo><mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: -0.177em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-n"><mjx-c class="mjx-c52"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2208"></mjx-c></mjx-mo><mjx-mi class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mi><mjx-mi class="mjx-n"><mjx-c class="mjx-c47"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-utext variant="normal" style="font-size: 85.2%; padding: 0.881em 0px 0.235em; font-family: MJXZERO, serif;">○</mjx-utext></mjx-mo></mjx-texatom><mjx-mi class="mjx-n"><mjx-utext variant="normal" style="font-size: 85.2%; padding: 0.881em 0px 0.235em; font-family: MJXZERO, serif;">σ</mjx-utext></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mi class="mjx-n"><mjx-c class="mjx-c68"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c64"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-n"><mjx-c class="mjx-c52"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-utext variant="normal" style="font-size: 85.2%; padding: 0.881em 0px 0.235em; font-family: MJXZERO, serif;">○</mjx-utext></mjx-mo></mjx-texatom><mjx-mi class="mjx-n"><mjx-utext variant="normal" style="font-size: 85.2%; padding: 0.881em 0px 0.235em; font-family: MJXZERO, serif;">σ</mjx-utext></mjx-mi></mjx-texatom></mjx-script></mjx-msub></mjx-texatom></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi><mi>u</mi><mi>l</mi><mi>e</mi><mi>s</mi><mrow data-mjx-texclass="ORD"><mo>=</mo><mi data-mjx-auto-op="false">Rsel</mi><mo stretchy="false">(</mo><mi mathvariant="normal">G</mi><mo>,</mo><mi mathvariant="normal">P</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">⟨</mo><mi mathvariant="normal">R</mi><mo>,</mo><mi mathvariant="normal">σ</mi><mo stretchy="false">⟩</mo><msub><mo stretchy="false">)</mo><mrow data-mjx-texclass="ORD"><mi mathvariant="normal">R</mi><mo>∈</mo><mi mathvariant="normal">P</mi><mi mathvariant="normal">G</mi><mrow data-mjx-texclass="ORD"><mo>○</mo></mrow><mi mathvariant="normal">σ</mi><mo>=</mo><mi data-mjx-auto-op="false">head</mi><mo stretchy="false">(</mo><mi mathvariant="normal">R</mi><mo stretchy="false">)</mo><mrow data-mjx-texclass="ORD"><mo>○</mo></mrow><mi mathvariant="normal">σ</mi></mrow></msub></mrow></math></mjx-assistive-mml></mjx-container><br>
   <strong>apply-rules</strong>(node, G, rules)</li>
  </ol>

  <p><strong>end</strong></p>
</div>
<hr>
<div class="l">
  <p class="courier">apply-rules:</p>
  <p><strong>if</strong> <em>empty?(rules)</em><br>
<strong>then output</strong> = <em>node</em>, i.e., the tree rooted at <em>node</em>. A <strong>failure backtracking point</strong>.</p>

  <p><strong>else</strong> assume that the first element in <em>rules</em> is ⟨R,σ⟩.</p>
  <ol>
    <li><strong>New query construction</strong>:<br>
  <em>new_query</em> = (<strong>replace</strong>(<em>label(node)</em>, <em>G</em>, <em>body(R)</em>)) ○ σ.<br>
  That is, if <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="3" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45C TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msub space="4"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-texatom space="2" texclass="ORD"><mjx-mi class="mjx-n"><mjx-c class="mjx-c6E"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2265"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msub space="4"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi><mo stretchy="false">(</mo><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>G</mi><mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>G</mi><mi>n</mi></msub><mo>,</mo><mrow data-mjx-texclass="ORD"><mi mathvariant="normal">n</mi><mo>≥</mo><mn>1</mn></mrow><mo>,</mo><mi>G</mi><mo>=</mo><msub><mi>G</mi><mi>i</mi></msub></math></mjx-assistive-mml></mjx-container>,<br>
  and <em>body(R) = B₁, …, Bₘ,</em> m≥1, then<br>
  <em>new_query</em> = <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="4" style="font-size: 117.4%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2E"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-utext variant="normal" style="font-size: 85.2%; padding: 0.881em 0px 0.235em; font-family: MJXZERO, serif;">○</mjx-utext></mjx-mo></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D70E TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>G</mi><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>B</mi><mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>B</mi><mi>m</mi></msub><mo>,</mo><msub><mi>G</mi><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mrow data-mjx-texclass="ORD"><mo>○</mo></mrow><mi>σ</mi></math></mjx-assistive-mml></mjx-container>.</li>
    <li><strong>New query expansion</strong>:<br>
  <strong>add_branch</strong>(<em>node</em>, ⟨<em>σ</em>, <em>number(R)</em>⟩,<br>
  <strong>proof-tree</strong>(<em>make_node</em>(<em>new_query</em>))</li>
    <li><strong>Application of other selected rules</strong>:<br>
  <strong>apply-rules</strong>(<em>node</em>, <em>G</em>, <em>tail</em>(<em>rules</em>))</li>
  </ol>

  <p><strong>end</strong></p>
</div>
<hr>

<p><strong>דוגמה 3</strong>: עצי הוכחה למעגלים לוגיים.</p>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">nand_circuit</span><span class="p">(</span><span class="nv">In1</span><span class="p">,</span> <span class="nv">In2</span><span class="p">,</span> <span class="nv">Out</span><span class="p">).</span>
</code></pre></div></div>

<p><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/tree1.png" alt=""></p>

<p>כל ענף הצלחה מהווה תשובה, שמתקבלת ע”י הרכבה של כל ההצבות על המסלול המוביל אל העלה, לפי הסדר.</p>

<p>בעלה ההצלחה קיבלנו:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{In1=Input1_1, In2=Input2_1, Out=Output_1}
	∘ {Input1_1=n3, X_1=n4, Output_1=n2}
	∘ {Input2_1=n5}
= {In1=n3, In2=Input2_1, Out=n2, Input1_1=n3, X_1=n4, Output_1=n2}
	∘ {Input2_1=n5}
= {In1=n3, In2=n5, Out=n2, Input1_1=n3, X_1=n4, Output_1=n2, Input2_1=n5}
</code></pre></div></div>
<p>בוחרים רק את המשתנים שמופיעים בשאילתה:<br>
<code class="language-plaintext highlighter-rouge">{In1=n3, In2=n5, Out=n2}</code> היא תשובה אפשרית (ויחידה) לשאילתה.</p>

<p>הסבר על הצלעות היוצאות מן השורש:</p>
<ol>
  <li>עבור nand_circuit נעשה rename, באמצעות הוספת מספר הגדל בכל שלב:
    <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">nand_circuit</span><span class="p">(</span><span class="nv">Input1_1</span><span class="p">,</span> <span class="nv">Input2_1</span><span class="p">,</span> <span class="nv">Output_1</span><span class="p">)</span> <span class="p">:-</span>
 <span class="ss">transistor</span><span class="p">(</span><span class="nv">Input1_1</span><span class="p">,</span> <span class="nv">X_1</span><span class="p">,</span> <span class="nv">Output_1</span><span class="p">),</span>
 <span class="ss">transistor</span><span class="p">(</span><span class="nv">Input2_1</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="nv">X_1</span><span class="p">),</span>
 <span class="ss">resistor</span><span class="p">(</span><span class="ss">power</span><span class="p">,</span> <span class="nv">Output_1</span><span class="p">).</span>
</code></pre></div>    </div>
  </li>
  <li>נעשה Unify של <code class="language-plaintext highlighter-rouge">nand_circuit(Input1_1, Input2_1, Output_1)</code> עם המטרה הנוכחית <code class="language-plaintext highlighter-rouge">nand_circuit(In1, In2, Out)</code>. התוצאה היא
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mgu={In1=Input1_1, In2=Input2_1, Out=Output_1}
</code></pre></div>    </div>
  </li>
  <li>גוף הכלל אחרי ההחלפה התווסף <u>בראש</u> המטרה הנוכחית:
    <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">transistor</span><span class="p">(</span><span class="nv">Input1_1</span><span class="p">,</span> <span class="nv">X_1</span><span class="p">,</span> <span class="nv">Output1</span><span class="p">),</span>
<span class="ss">transistor</span><span class="p">(</span><span class="nv">Input2_1</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="nv">X_1</span><span class="p">),</span>
<span class="ss">resistor</span><span class="p">(</span><span class="ss">power</span><span class="p">,</span> <span class="nv">Output_1</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<div class="av">
  <h3 id="section">2.3 סוגי הרקורסיה</h3>

  <p><strong>הגדרות</strong>:</p>
  <ul>
    <li><strong>עץ הצלחה</strong> הוא עץ הוכחה שיש בו לפחות מסלול הצלחה אחד.</li>
    <li><strong>עץ כישלון</strong> הוא עץ הוכחה שכל המסלולים בו הם מסלולי כישלון.</li>
    <li><strong>עץ אינסופי</strong> הוא עץ הוכחה שיש בו לפחות מסלולי אינסופי אחד. לדוגמה, באמצעות הכלל</li>
  </ul>
</div>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">p</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">p</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="ss">q</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</code></pre></div></div>
<p>השאילתה</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">p</span><span class="p">(</span><span class="nv">A</span><span class="p">).</span>
</code></pre></div></div>
<p>תכנס ללולאה אינסופית כתוצאה מכלל הבחירה של סדר ה-goals בפרולוג.</p>
<ul>
  <li>אחרת מדובר ב<strong>עץ סופי</strong>.
ניתן לנסות להימנע מיצירת מסלולים אינסופיים, לדוגמה:
    <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">p</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">q</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="ss">p</span><span class="p">(</span><span class="nv">Y</span><span class="p">).</span>
</code></pre></div>    </div>
    <p>המקרה הראשון נקרא “רקורסיה שמאלית”. אין ליצור אותה בתוכניות פרולוג. המקרה השני נקרא “רקורסיית זנב”.
לדוגמה, העץ המצויר לעיל הוא עץ סופי, עץ הצלחה, שיש בו מסלול הצלחה אחד ושני מסלולי כישלון.</p>
  </li>
</ul>

<p><strong>הערה</strong>: מכיוון שלא ניתן לדעת האם כל המסלולים בעץ אינסופי הם מסלולי כישלון, לא קיים עץ כישלון אינסופי.<br>
<strong>שאלה</strong>: איך ישפיע שינוי סדר בחירת הכללים או בחירת ה-goals או הכללים על הרקורסיה הנ”ל?</p>

<p><strong>חומר השלמה</strong>:<br>
<strong>דוגמה 4</strong>. SQL in Relational Logic Programming<br>
נציג את יחסי נגד וטרנזיסטור כשתי טבלאות:</p>

<table class="l">
  <tbody>
    <tr>
      <td><strong>Table name</strong>: resistor<br><strong>Schema</strong>: End1, End2<br><strong>Data</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(power, n1),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(power, n2),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n1, power),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n2, power).</td>
      <td><strong>Table name</strong>: transistor<br><strong>Schema</strong>: Gate, Source, Drain<br><strong>Data</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n2, ground, n1),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n3, n4, n2),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n5, ground, n4).<br>&nbsp;</td>
    </tr>
  </tbody>
</table>

<p class="l"><strong><u>SQL Operations:</u></strong></p>
<p class="l"><strong>1) Join</strong></p>
<p>הפעולה מאחדת שתי טבלאות על סמך עמודות משותפות.</p>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: res_join_trans(End1, X, Source, Drain)/4</span>
<span class="c1">% Purpose: join between resistor and transistor according</span>
<span class="c1">%          to End2 of resistor and Gate of transistor.</span>
<span class="ss">res_join_trans</span><span class="p">(</span><span class="nv">End1</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Drain</span><span class="p">)</span> <span class="p">:-</span>            <span class="c1">%1</span>
	<span class="ss">resistor</span><span class="p">(</span><span class="nv">End1</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span>
	<span class="ss">transistor</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Drain</span><span class="p">).</span>
<span class="o">?-</span> <span class="ss">res_join_trans</span><span class="p">(</span><span class="nv">End1</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Drain</span><span class="p">).</span>
<span class="nv">End1</span> <span class="o">=</span> <span class="ss">power</span><span class="p">,</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">n2</span><span class="p">,</span>
<span class="nv">Source</span> <span class="o">=</span> <span class="ss">ground</span><span class="p">,</span>
<span class="nv">Drain</span> <span class="o">=</span> <span class="ss">n1</span> <span class="p">;</span>
<span class="ss">false</span><span class="p">.</span>
</code></pre></div></div>

<p class="l"><strong>2) Transitive closure of the resistor relation</strong></p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: res_closure(X, Y)/2</span>
<span class="ss">res_closure</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">resistor</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>            <span class="c1">%1</span>
<span class="ss">res_closure</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">resistor</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span>            <span class="c1">%2</span>
                     <span class="ss">res_closure</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="o">?-</span> <span class="ss">res_closure</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">power</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">n1</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">power</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">n2</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">n1</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">power</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">n2</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">power</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">power</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">power</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">power</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">n1</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">power</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">n2</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">power</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">power</span> <span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="ss">power</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="ss">n1</span> <span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div>
<p>קיבלנו את אותן תוצאות אינספור פעמים, בגלל הסימטריות של נגד.</p>

<p class="l"><strong>3) Projection.</strong></p>
<p>למצוא רק חלק מהמשתנים.</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: resistor_end1(End)/1</span>
<span class="c1">% Purpose: Find all options of the first resistor's end.</span>
<span class="ss">resistor_end1</span><span class="p">(</span><span class="nv">End1</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">resistor</span><span class="p">(</span><span class="nv">End1</span><span class="p">,</span> <span class="nv">_</span><span class="p">).</span>           <span class="c1">%1</span>
<span class="o">?-</span> <span class="ss">resistor_end1</span><span class="p">(</span><span class="nv">End1</span><span class="p">).</span>
<span class="nv">End1</span> <span class="o">=</span> <span class="ss">power</span> <span class="p">;</span>
<span class="nv">End1</span> <span class="o">=</span> <span class="ss">power</span> <span class="p">;</span>
<span class="nv">End1</span> <span class="o">=</span> <span class="ss">n1</span> <span class="p">;</span>
<span class="nv">End1</span> <span class="o">=</span> <span class="ss">n2</span><span class="p">.</span>
</code></pre></div></div>

<p class="l"><strong>4) Selection.</strong></p>
<p>למצוא פתרונות כשערכו של אחד מהמשתנים כבר ידוע.</p>

<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: tr_ground_source(X1, X2, X3)/3</span>
<span class="c1">% Purpose: Select all transistors with ground sources.</span>
<span class="ss">tr_ground_source</span><span class="p">(</span><span class="nv">X1</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="nv">X3</span><span class="p">)</span> <span class="p">:-</span>
	<span class="ss">transistor</span><span class="p">(</span><span class="nv">X1</span><span class="p">,</span> <span class="nv">X2</span><span class="p">,</span> <span class="nv">X3</span><span class="p">),</span>
	<span class="nv">X2</span> <span class="o">=</span> <span class="ss">ground</span><span class="p">.</span>              <span class="c1">%1</span>
</code></pre></div></div>
<p>או, פשוט:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">tr_ground_source</span><span class="p">(</span><span class="nv">X1</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="nv">X3</span><span class="p">)</span> <span class="p">:-</span>
	<span class="ss">transistor</span> <span class="p">(</span><span class="nv">X1</span><span class="p">,</span> <span class="ss">ground</span><span class="p">,</span> <span class="nv">X3</span><span class="p">).</span>
</code></pre></div></div>
<p><strong>הערה</strong>: אופרטור שווה מתפקד כאופרטור יוניפיקציה בפרולוג.</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">tr_ground_source</span><span class="p">(</span><span class="nv">Y1</span><span class="p">,</span> <span class="nv">Y2</span><span class="p">,</span> <span class="nv">Y3</span><span class="p">).</span>
<span class="nv">Y1</span> <span class="o">=</span> <span class="ss">n2</span><span class="p">,</span>
<span class="nv">Y2</span> <span class="o">=</span> <span class="ss">ground</span><span class="p">,</span>
<span class="nv">Y3</span> <span class="o">=</span> <span class="ss">n1</span> <span class="p">;</span>
<span class="nv">Y1</span> <span class="o">=</span> <span class="ss">n5</span><span class="p">,</span>
<span class="nv">Y2</span> <span class="o">=</span> <span class="ss">ground</span><span class="p">,</span>
<span class="nv">Y3</span> <span class="o">=</span> <span class="ss">n4</span><span class="p">.</span>
</code></pre></div></div>

<h2 id="3-logic-programming">3. Logic Programming</h2>

<p>Relational logic programming משמש לתיאור טיפוסים אטומיים. על מנת לתאר טיפוסים מורכבים מוסיפים סימני פונקציות, הנקראים <strong><em>פנקטורים</em></strong> (functors).</p>

<p><strong>דוגמה 5</strong>: נבנה עץ בינארי ונחפש איבר מסוים בו. נייצג קדקוד בצורה tree(Node, Left, Right). עלה הוא קדקוד ששני הענפים שלו לא קיימים (nil).</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: tree_member(Element, Tree)/ 2</span>
<span class="c1">% Purpose: Testing tree membership, checks if Element is</span>
<span class="c1">%          an element of the binary tree Tree.</span>
<span class="ss">tree_member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">_Left</span><span class="p">,</span> <span class="nv">_Right</span><span class="p">)).</span>             <span class="c1">%1</span>
<span class="ss">tree_member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="nv">_Y</span><span class="p">,</span> <span class="nv">Left</span><span class="p">,</span> <span class="nv">_Right</span><span class="p">))</span> <span class="p">:-</span>           <span class="c1">%2</span>
	<span class="ss">tree_member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Left</span><span class="p">).</span>
<span class="ss">tree_member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="nv">_Y</span><span class="p">,</span> <span class="nv">_Left</span><span class="p">,</span> <span class="nv">Right</span><span class="p">))</span> <span class="p">:-</span>           <span class="c1">%3</span>
	<span class="ss">tree_member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Right</span><span class="p">).</span>
</code></pre></div></div>
<p>כאן tree_member הוא <strong><em>שם הפרדיקט</em></strong>, tree הוא <strong><em>פנקטור</em></strong> המופעל על שלושה ביטויים. הם נראים זהים אך נבדלים במיקום ומטרה: פרדיקט מופיע בראש נוסחה אטומית, פנקטור הוא בנאי ערך המופיע כחלק מהנוסחה. פנקטור יכול להיות מקונן, פרדיקט לא.<br>
יכולנו להשתמש באותו שם בדיוק עבור שניהם, וזאת לא הייתה טעות. למשל:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">in_tree</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="ss">in_tree</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">_Left</span><span class="p">,</span> <span class="nv">_Right</span><span class="p">)).</span>
</code></pre></div></div>
<p>התפקיד של in_tree נקבע כל פעם לפי מיקומו.</p>

<p>א. <strong>יוניפיקציה בתכנות הלוגי</strong>. עקב קיום הפנקטורים האלגוריתם דורש יותר עבודה. לדוגמה, שלב אחרי שלב: Unify(A, B), כאשר</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = tree_member(tree(X, 10, f(X)), W)
B = tree_member(tree(Y, Y, Z), f(Z))
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. s={X=Y}                              A⚬s= tree_member(tree(Y, 10, f(Y)), W)
                                        B⚬s= tree_member(tree(Y, Y, Z), f(Z))
2. s={X=10, Y=10}                       A⚬s= tree_member(tree(10, 10, f(10)), W)
                                        B⚬s= tree_member(tree(10, 10, Z), f(Z))
3. s={X=10, Y=10, Z=f(10)}              A⚬s= tree_member(tree(10, 10, f(10)), W)
                                        B⚬s= tree_member(tree(10, 10, f(10)), f(f(10)))
4. s={X=10, Y=10, Z=f(10), W=f(f(10))}  A⚬s= tree_member(tree(10,10, f(10)), f(f(10)))
                                        B⚬s= tree_member(tree(10,10,f(10)), f(f(10)))
</code></pre></div></div>
<p>במהלך האלגוריתם יש להפעיל occurs check, לבדיקה שהקשירות אינן מעגליות, כמו בקשירה X = f(X). אם ננסה להפעיל את האלגוריתם עבור</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = tree_member(tree(X, Y, f(X)), X)
B = tree_member(tree(Y, Y, Z), f(Z))
</code></pre></div></div>
<p>נקבל {X=Y, Z=f(Y), Y= f(f(Y))}, וההצבה לא אפשרית.</p>

<p>ב. <strong>חישובי שאילתות:</strong></p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">tree_member</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="ss">nil</span><span class="p">,</span> <span class="ss">nil</span><span class="p">)).</span>
<span class="ss">true</span>
<span class="o">?-</span> <span class="ss">tree_member</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="ss">nil</span><span class="p">,</span> <span class="ss">nil</span><span class="p">),</span>
   <span class="ss">tree</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="ss">nil</span><span class="p">,</span> <span class="ss">nil</span><span class="p">))).</span>
<span class="ss">true</span><span class="p">.</span>
<span class="o">?-</span> <span class="ss">tree_member</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">)).</span>
<span class="ss">false</span><span class="p">.</span>
<span class="o">?-</span> <span class="ss">tree_member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="ss">tree</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="ss">nil</span><span class="p">,</span> <span class="ss">nil</span><span class="p">),</span>
   <span class="ss">tree</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="ss">nil</span><span class="p">,</span> <span class="ss">nil</span><span class="p">))).</span>
<span class="nv">X</span><span class="o">=</span><span class="m">1</span><span class="p">;</span>
<span class="nv">X</span><span class="o">=</span><span class="m">2</span><span class="p">;</span>
<span class="nv">X</span><span class="o">=</span><span class="m">3</span><span class="p">;</span>
<span class="ss">false</span>
</code></pre></div></div>

<p><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/tree2.png" alt=""></p>

<p>נקבל את התשובה התחתונה בעץ המתקבל בעזרת ההרכבה:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{X_1=X, _Y_1=1, _Left_1=tree(2, nil, nil), Right_1=tree(3, nil, nil)}
	∘ {X_2=3, X=3, _Left_2=nil, _Right_2=nil}
= {X_1=3, _Y_1=1, _Left_1=tree(2, nil, nil), Right_1=tree(3, nil, nil), X_2=3, X=3,
	_Left_2=nil, _Right_2=nil}
</code></pre></div></div>
<p>בוחרים את X:‏ {X = 3}.</p>

<p>להשוואה, נבדוק את הקוד התואם ב-Scheme. ניתן לראות שנצטרך כמה פרוצדורות שונות כדי לקבל פונקציונליות שקולה. למשל,</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">tree-member?</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">t</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nf">empty?</span> <span class="nv">t</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
          <span class="p">((</span><span class="nb">pair?</span> <span class="nv">t</span><span class="p">)</span>
                     <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">eq?</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">t</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">tree-member?</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">t</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">tree-member?</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">t</span><span class="p">))))</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">eq?</span> <span class="nv">x</span> <span class="nv">t</span><span class="p">)))))</span>
</code></pre></div></div>
<p>תטפל רק במקרה בו גם x וגם t ידועים מראש.</p>

<div class="av">
  <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">tree_member</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</code></pre></div>  </div>
  <pre>T = tree(1, _G445, _G446) ;
T = tree(<b>_G444</b>, tree(1, _G449, _G450), _G446) ;
T = tree(<b>_G444</b>, tree(_G448, tree(1, _G453, _G454), _G450), _G446) ;
...
</pre>
</div>

<p>כשאנו מנסים למצוא את כל העלים שכוללים את 1, נקבל עץ הצלחה אינסופי, כשהתשובות ידועות חלקית (partially instantiated).<br>
ניתן לראות את פעולת ה-backtracking שבה האינטרפרטר מוצא פתרון נוסף לבן שמאלי.<br>
<strong>הערה</strong>: קיימים שני סוגי backtracking – הצלחה וכישלון. במקרה של הצלחה, האלגוריתם מגיע לעלה הצלחה וחוזר כדי להמשיך בחיפוש הוכחות נוספות. במקרה של כישלון, האלגוריתם לא יכול להמשיך הוכחה כי לא ניתן לעשות יוניפיקציה של ה-goal הנבחר עם אף ראש כלל, והאלגוריתם חוזר לחיפוש נתיבי הוכחה אחרים.</p>

<p>שימוש בכלל שדורש קלט מוגדר עם משתנים מצליח לפעמים ליצור את כל התשובות האפשריות. במקרה כזה אנו אומרים כי מדובר בכלל generator.<br>
כשאנו נזכרים בקוד של רקורסיה שמאלית</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">p</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="ss">p</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="ss">q</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</code></pre></div></div>
<p>ניתן להבין כי p/1 למעשה הופך ל-generator, כאשר נקרא באמצעות שאילתה ללא משתנה קשור, אם כי הוא לא מצליח ליצור אפילו את התשובה הראשונה:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?</span> <span class="o">-</span> <span class="ss">p</span><span class="p">(</span><span class="nv">A</span><span class="p">).</span>
</code></pre></div></div>
<p><strong>הערה נוספת</strong>: נשים לב לחשיבות פעולת ה-rename. אם היינו בוחרים להריץ את שאילתת ה-generator הנ”ל בצורה הבאה:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?-</span> <span class="ss">tree_member</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
</code></pre></div></div>
<p>מבלי לבצע rename, לא היינו יכולים לקבל אף הוכחה עקב בעיית יוניפיקציה – X היה עץ עם פנקטור tree ומספר 1 בו זמנית.</p>

<p><strong>חומר השלמה:</strong></p>

<p><strong>דוגמה 6.</strong><br>
בהינתן נוסחה לוגית יש לבדוק האם היא נכונה, כלומר ערכה הוא אמת או שקר. ניתן לייצג נוסחה ע”י פרימיטיביים yes, no (המיוצגות ע”י קבועים), ופעולות and, or, not (המיוצגות ע”י יחסים). נקבל רקורסיה הדדית:</p>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: satisfiable(Formula) / 1</span>
<span class="c1">% Purpose: There is a true instance</span>
<span class="c1">%          of the Boolean formula.</span>
<span class="ss">satisfiable</span><span class="p">(</span><span class="ss">yes</span><span class="p">).</span>                               <span class="c1">%1</span>
<span class="ss">satisfiable</span><span class="p">(</span><span class="ss">and</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">))</span> <span class="p">:-</span> <span class="ss">satisfiable</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>       <span class="c1">%2</span>
                          <span class="ss">satisfiable</span><span class="p">(</span><span class="nv">Y</span><span class="p">).</span>
<span class="ss">satisfiable</span><span class="p">(</span><span class="ss">or</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">_</span><span class="p">))</span> <span class="p">:-</span> <span class="ss">satisfiable</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>        <span class="c1">%3</span>
<span class="ss">satisfiable</span><span class="p">(</span><span class="ss">or</span><span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">Y</span><span class="p">))</span> <span class="p">:-</span> <span class="ss">satisfiable</span><span class="p">(</span><span class="nv">Y</span><span class="p">).</span>        <span class="c1">%4</span>
<span class="ss">satisfiable</span><span class="p">(</span><span class="ss">not</span><span class="p">(</span><span class="nv">X</span><span class="p">))</span> <span class="p">:-</span> <span class="ss">wrong</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>                <span class="c1">%5</span>
</code></pre></div></div>
<div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Signature: wrong(Formula) / 1</span>
<span class="c1">% Purpose: There is a false instance</span>
<span class="c1">%          of the Boolean formula (De Morgan's laws).</span>
<span class="ss">wrong</span><span class="p">(</span><span class="ss">no</span><span class="p">).</span>                              <span class="c1">%1</span>
<span class="ss">wrong</span><span class="p">(</span><span class="ss">or</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)):-</span> <span class="ss">wrong</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>             <span class="c1">%2</span>
                  <span class="ss">wrong</span><span class="p">(</span><span class="nv">Y</span><span class="p">).</span>
<span class="ss">wrong</span><span class="p">(</span><span class="ss">and</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">_</span><span class="p">))</span> <span class="p">:-</span> <span class="ss">wrong</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>           <span class="c1">%3</span>
<span class="ss">wrong</span><span class="p">(</span><span class="ss">and</span><span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">Y</span><span class="p">))</span> <span class="p">:-</span> <span class="ss">wrong</span><span class="p">(</span><span class="nv">Y</span><span class="p">).</span>           <span class="c1">%4</span>
<span class="ss">wrong</span><span class="p">(</span><span class="ss">not</span><span class="p">(</span><span class="nv">X</span><span class="p">))</span> <span class="p">:-</span> <span class="ss">satisfiable</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>        <span class="c1">%5</span>
</code></pre></div></div>

<p class="c"><img src="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/tree3.png" alt=""></p>
<link rel="stylesheet" type="text/css" href="./עקרונות שפות תכנות – אביב 2021תרגול 11. תכנות לוגי – חלק א’ _ Principles of Programming Languages_files/style(1).css" media="all">



        <footer class="site-footer">
            
            <span class="site-footer-owner"><a href="https://github.com/bguppl/interpreters">interpreters</a> is maintained by <a href="https://github.com/bguppl">bguppl</a>.</span>
            
            <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com/">GitHub
                    Pages</a>.</span>
        </footer>
    </main>


<div id="give-freely-root-ejkiikneibegknkgimmihdpcbcedgmpo" class="give-freely-root" data-extension-id="ejkiikneibegknkgimmihdpcbcedgmpo" data-extension-name="Volume Booster" style="display: block;"><template shadowrootmode="open"><style>
  :host {
    all: initial;
  }

  .gf-scroll-remove::-webkit-scrollbar {
    border-radius-bottom-right: 15px;
  }

  button {
    cursor: pointer;
    transition: transform 0.1s ease;
  }

  button:active {
    transform: scale(0.98);
  }

  .give-freely-close-button:hover {
    opacity: 0.7;
  }

  input[type="radio"] {
    margin-right: 8px;
  }

  hr {
    border: none;
    border-top: 1px solid #e5e5e5;
    margin: 1em 0;
  }

  @media (max-width: 600px), (max-height: 480px) {
    #give-freely-checkout-popup {
      display: none !important;
    }
  }
</style><div><div class="gf-app"></div></div></template></div></body></html>